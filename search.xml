<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[handler与UI更新]]></title>
    <url>%2F2018%2F02%2F15%2Fhandler%2F</url>
    <content type="text"><![CDATA[Android规定更新UI的操作只能在主线程进行，因为UI是在主线程创建的，所以只能在主线程更新，当然，我们也可以使用另一种说法，UI只能在它被创建的线程进行更新。 在这样的情况下，我们只能在子线程进行完耗时操作之后再由主线程进行更新，而Handler正是我们寻找的用于解决这个问题的关键。 组成Android的异步消息处理主要有四个部分组成，分别为：Message、Handler、MessageQueue和Looper MessageMessage是在线程之间传递的消息，它可以携带少量的数据，用于在不同线程之间交换数据 HandlerHandler是用于发送消息和处理消息的，发送消息一般是使用Handler的sendMessage（）方法发送到MessageQueue等待取出，而发出的消息经过一系列地辗转后，又会传递到Handler的handleMessage（）方法中，handleMessage方法运行的线程是handler被创建的线程，一般为主线程。 MessageQueueMessageQueue是消息队列的意思，它主要用于存放需要通过Handler发送的消息，等待被Looper取出处理(Looper会回调dispatchMessage()方法将消息发送给Handle)，每个线程只会有一个MessageQueue对象 LooperLooper是每个线程中的MessageQueue的管家，每个线程的MessageQueue只会对应有一个Looper对象，调用Looper的loop()方法后，Looper就会无限循环地检查MessageQueue中是否存在消息，每当发现MessageQueue中存在一条消息，就会将它取出，并使用dispatchMessage()方法传递到Handler的handleMessage()方法中。 示意图 图片来源于链接]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git高级命令]]></title>
    <url>%2F2018%2F02%2F15%2Fgitpro%2F</url>
    <content type="text"><![CDATA[汇总 git中比较复杂的命令如下表所示： 命令 作用 git rebase 在新位置重新提交 git revert 撤销commit git reset 丢弃提交 git stash 临时存放工作目录的改动 git reflog 找回分支 git rebase作用rebase的意思是，给你的commit序列重新设置基础点（也就是父commit）。展开来说就是，把你指定的commit以及它所在的 commit 串，以指定的目标commit为基础，依次重新提交一次。这和merge的不同点在于merge会发生分支散开又合并的情况，而用rebase则不会。 注意：当使用rebase时，必须先checkout到分支，不能在默认分支（master）上直接使用rebase，它会时主分支上新的commit消失。在使用rebase后，可以使用merge来移动到最新的提交。 git revert作用revert的作用时撤销提交上去的commit，希望撤销哪个commit，就把哪个填在后面，用法为：git revert 提交名 注意：使用revert并不会修改提交历史，而是生成新的commit，所以是一种安全的方法 git reset作用git reset的作用与git revert的作用比较相似，不同点在于git reset撤销的是还没有被push的提交，git revert撤销的则是已经被push的提交，因为git revert不会修改提交历史，而reset则会修改。 reset可加三种修饰，有着三种不同的作用，如下 修饰 作用 说明 – mixed 保留工作目录，并清空暂存区 重置位置的同时，保留工作目录的内容，也就是修改为新commit已完成，但是还没提交到本地仓库的样子 – hard 重置工作目录 重置位置的同时，清空工作目录的所有改动,恢复成目前head所值的commit的样子 – soft 保留工作目录 把后面修改的内容都放进暂存区 git stash作用stash的作用就是把当前工作目录先隐藏起来，等到需要的时候再拿出来，拿出来时就使用git stash pop git reflog作用reflog可以查看head的移动历史，如果我们刚刚删除了一个分支，可以通过reflog查看分支，再通过checkout切换到那个分支]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask解析]]></title>
    <url>%2F2018%2F02%2F15%2FAysncTask%2F</url>
    <content type="text"><![CDATA[在Android AsyncTask中有以下几个主要的函数： onPreExecute() doInBackground(Params…) onProgressUpdate(Progress…) onPostExecute(Result) 函数的作用及解析onPreExecute()这个方法是在主线程中执行的，一般在任务执行前做准备工作。 doInBackground(Params…)这个方法是在onPreExecute() 中执行的，运行在线程池中，用来执行较为耗时的操作，在执行过程中可以调用publishProgress(Progress…values)来更新进度信息。 onProgressUpdate(Progress…)这个方法在主线程中执行，当调用publishProgress(Progress…value)时，此方法会将进度更新到UI组件上。 这个方法实际上是线程池执行任务过程中的回调，用来显示当前的进度。 onPostExecute(Result result)在主线程中执行，当后台任务执行完成后，它会被执行。也就是在线程池完成任务后的回调。 其他：与设计模式相关我们在使用AsyncTask执行后台任务的时候会这样： 1new ConcreteAsyncTask().execute; //ConcreteAsyncTask即为我们定义的后台工作类 而实际上，execute方法其实是一次模板方法模式的使用，在execute规定好了各个函数的执行顺序。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git基础命令汇总]]></title>
    <url>%2F2018%2F02%2F14%2FGitCommand%2F</url>
    <content type="text"><![CDATA[汇总表如下所示 命令 作用 注意事项 git clone 把远程仓库取到本地 可能会需要输入GitHub的帐户名和密码，其中密码时不显示输入的 git log 查看历史记录 加上后缀-p查看详细历史，–stat查看简要统计，查看完按q键退出 git status 查看工作目录当前状态 git show 查看具体的 commit 查看当前的commit可以直接使用git show，看指定的commit需要加上这个commit的引用或者SHA-1码 git diff 查看未提交的内容 直接使用查看工作目录和暂存区的不同，使用git diff –staged可以显示暂存区和上一条提交之间的不同，使用git diff HEAD可以显示工作目录和上一条提交之间的不同 git add 把文件提交到暂存区 可以使用git add .来直接把工作目录下的所有改动全部放进暂存区，也可以git add 文件名放入单个文件 git commit 把文件提交到本地仓库 一般还要通过-m参数提交描述信息，否则要进入编辑模式编辑提交信息,commit –amend可以修改已经提交到本地仓库的commit并生成新commit git push 把当前 branch 的位置上传到远端仓库 如果当前分支并不是默认分支，则使用git push origin 分支名提交到远程仓库，使用-f可以忽略冲突，强制push git pull 从远程仓库更新内容 git branch 分支名 创建新分支 git branch -d 名称可以删除一个分支（默认分支不可删除） git checkout 分支名 切换到分支 可以使用git checkout -b 名称来把创建分支和切换到分支的操作合并 git merge 分支名 把目标分支上的所有commit的内容与当前commit合并生成一个新的commit 可能需要手动解决冲突，放弃解决冲突的话可以使用git merge –abort]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[垃圾回收机制]]></title>
    <url>%2F2018%2F02%2F14%2FtrashRecycle%2F</url>
    <content type="text"><![CDATA[内存区域一块Java堆空间一般分为三个部分：年轻代、年老代和永久代（java8之前为永久代，java8移除了永久代，改为了元空间） 各个部分的对比如下： 部分 特点 存放对象 回收算法 新生代(Young Generation) 存活对象少，垃圾多 刚刚创建的对象 Copying算法 年老代(Old Generation) 存活对象多，垃圾少 存活了一段时间的对象 标记(Mark)算法 持久代(Permanent Generation)(已移除) 对垃圾回收没有显著影响 静态的类和方法 无 元空间(Metaspace)(代替持久代) 与堆不相连的本地内存区域 类的元数据信息 无 新生代简介新生代分为三个区，一个Eden区，另外的两个S0和S1都是Survivor区（这两个区本质一样，可互换）,程序中生成的大部分新的对象都是在Eden区中，当Eden区满时，还存活的对象将被复制到其中一个Survivor区，当此Survivor区的对象占用空间满时，此区存活的对象又被复制到另一个Survivor区，当这个Survivor区也满时，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到年老代。 Copying算法扫描出存活的对象，并复制到一块新的完全未使用的空间中，就是在Eden、S0和S1之间copy。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在Young Generation区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。当连续分配对象时，对象会逐渐从Eden到Survivor，最后到Old Generation。 Eden：S0：S1默认为8：1：1 年老代简介年老代存放的是上面年轻代复制过来的对象，也就是在年轻代中还存活的对象，并且区满了复制过来的。一般来说，年老代中的生命周期都比较长。 Mark算法扫描出存活的对象，然后再回收未被标记的对象，回收后对空出的空间要么合并，要么标记出来便于下次分配，以减少内存碎片带来的效率损耗。 持久代用于存放静态的类和方法，持久代对垃圾回收算法没有显著影响。 持久代在JDK8.0时已经被废弃，元空间取而代之。 元空间用于存放类的元数据信息，在JDK8.0中出现，替代了持久代，相比于持久代，因为它是在与堆不相连的内存区域中，所以可以被JVM动态扩展。 内存对象的处理过程 对象创建后在Eden区 执行GC时，如果对象仍然存过，则复制到S0区 当S0区满时，该区存活对象将复制到S1区，然后S0清空，接下来S0和S1角色互换 当第三步达到一定次数后，存活对象将被复制到Old Generation（年老代） 当这个对象在Old Generation区域停留的时间达到一定程度时，它会被移动到Old Generation，最后积累一定时间再移动到Permanent Generation区域（JDK8.0为MetaSpace区域）]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JVM类加载机制]]></title>
    <url>%2F2018%2F02%2F13%2FjvmclassLoad%2F</url>
    <content type="text"><![CDATA[Java 虚拟机一般使用 Java 类的流程为：首先将开发者编写的 Java 源代码（.java文件）编译成 Java 字节码（.class文件），然后类加载器会读取这个 .class 文件，并转换成 java.lang.Class 的实例。有了该 Class 实例后，Java 虚拟机可以利用 newInstance 之类的方法创建其真正对象了。而这个过程，就是JVM的类加载。 概念虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 过程类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。 Class文件的来源 开发者编写的类 Java内部自带的核心类 Java核心扩展类 动态加载远程的.class文件 这些文件分别由AppClassLoader（系统加载器）、BootstrapClassLoader(启动类加载器)、ExtClassLoader（类扩展加载器)和自定义的ClassLoader进行加载 双亲加载机制某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 实现过程 检查目标.class文件是否加载过，如果加载过则直接返回 如果没加载过，把加载请求传递给父类加载器去加载 如果父类加载器加载成功，则直接返回 如果父类加载器未加载到，则自身加载]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Collection的方方面面]]></title>
    <url>%2F2018%2F02%2F13%2FcollectionRealize%2F</url>
    <content type="text"><![CDATA[Collection的主要子接口有List、Set和Queue。 ListArrayList与LinkedListList两个主要的实现类为ArrayList和LinkedList，区别如下： List类 原理 特点 ArrayList 采用数组形式来保存对象，将对象放在连续的位置中 长于随机访问元素，但是中间插入和移除元素较慢，非线程安全的 LinkedList 将对象存放在独立的空间中，而且在每个空间还保存下一个链接的索引 查询较慢，插入和删除较快，非线程安全的 VectorVector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。 Vector是一个古老的类，一般不使用它 SetSet的主要实现类有HashSet、LinkedHashSet、TreeSet。三者的比较如下： Set类 原理 特点 HashSet HashSet的底层是一个HashMap，当向HashSet插入元素时，实际上是向HashMap插入元素，插入的元素是作为Key储存的，键对值为一个特定值PRESENT 排列顺序不定，线程不安全 LinkedHashSet LinkedHashSet继承于HashSet，但与HashSet不同的是，它在内部维护着一个双向链表，这个链表保持着元素的次序 插入的性能弱于HashMap，但是迭代的性能好于HashMap，线程不安全 TreeSet TreeSet实现的是Set的子接口SortSet保证了添加的元素按照元素的自然顺序(递增或其他顺序)在集合中进行存储,需要实现Comparator接口，是基于TreeMap来实现的 需要比较，性能较差，线程不安全 注：以上三个类都可以通过Collections.synchronizedSet(？ extend Set)来实现线程安全 QueueQueue接口的实现类比较少，我们平常使用到的就是PriorityQueue和LinkedList，其中LinkedList是既实现了List接口又实现了Queue接口的。 PriorityQueue原理PriorityQueue是基于最小堆实现的，继承了AbstractQueue没有实现BlockingQueue接口，所以没有take阻塞方法。 整体关系图如下 图片来源于 链接]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Map的方方面面]]></title>
    <url>%2F2018%2F02%2F13%2FMapRealize%2F</url>
    <content type="text"><![CDATA[常见的Map实现类 Map类 特性 HashTable Map基于散列表的实现，HashTable继承自抽象类Dictionary（Dictionary是一个被废弃的接口），是线程安全的。 HashMap Map基于散列表的实现（取代了HashTable）。继承自抽象类AbstractMap，插入和查询“键对值”的开销是固定的。 LinkedHashMap 类似于HashMap，但是迭代遍历它时，取得“键对值”的顺序时其插入顺序，或者是LRU（最近最少使用）的次序，使用链表维护内部次序，所以迭代访问更快。 TreeMap 基于红黑树（自平衡二叉查找树）的实现，查看“键”或者“键对值”时，它们会被排序。特点是得到的结果是经过排序的，TreeMap也是唯一的带有SubMap（）方法的Map，可以返回一个子树。 WeakHashMap 弱键映射，允许释放映射所指向的对象，如果除映射之外没有引用指向某个“键”，那么此“键”可以被垃圾收集器回收。 ConcurrentHashMap 一种线程安全的Map，它不涉及同步加锁。 IdentityHashMap 使用==代替equals（）对“键”进行比较的散列映射。 HashMap与HashTable的比较HashMap与HashTable推出的时间是不同的，HashTable是jdk1.1就被推出的类，现在已经被遗弃，而HashMap则是用来替换它的类，具体比较如下 比较点 HashMap HashTable 性能 采用异步处理方式，性能更高 采用同步处理方式，性能较低 线程安全 非线程安全 线程安全 空键 允许将key设置为null 不允许将key设置为null，否则将报空指针异常 HashTable是使用synchronized关键字来实现线程互斥来达到线程同步的目的的 HashMap的实现HashMap内部维护着一个散列表，当我们使用put函数的时候，会调用Hash方法对Key做Hash（即通过hashCode()的高16位异或低16位）得到bucket位置，然后再进行储存，HashMap会根据当前bucket的占用情况自动调整容量。使用get函数获取对象时，与put方法一样，先对Key做hash，得到Bucket的位置，再通过equals()方法来确定键对值。当发生Hash冲突时，在JDK8之前，会使用一个链表将同一Bucket的元素组织起来，使用get方法时再进行遍历；在JDK8中，将链表改为了TreeMap，提高了查询效率。 更高效的线程同步Map-ConcurrentHashMapConcurrentHashMap采用了分段锁的设计，只有在同一个分段内才存在竞态关系，不同的分段锁之间没有锁竞争。这个容器的实现是基于Java内存模型的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中Thread类的方法(一)]]></title>
    <url>%2F2018%2F02%2F12%2FthreadMethod%2F</url>
    <content type="text"><![CDATA[启动有关方法run新启动的线程的操作都编写在run方法中，新线程启动后，会调用run方法，随后，当run方法执行结束时，线程也会跟着终止。 start调用start方法后，程序会在后台启动新的线程，又这个线程来执行run方法，需要注意的是，并表示一用start就会启动新线程，启动新线程的时间由系统决定 sleepsleep方法是让线程暂停一定的时间，暂停的时间是以毫秒为单位的 协作有关方法waitwait方法会让线程进入等待队列,任何实例都有一个等待队列，当执行wait语句后，当前线程就会暂停运行，并进入执行wait方法的实例的等待队列 notifynotify方法会将等待队列中的一个线程取出并唤醒，不过取出的线程是不一定的 notifyAllnotify方法会将等待队列中的全部线程取出并唤醒 注意，以上三个方法都要求线程必须持有锁，也就是必须在synchronized方法或者代码块中]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[synchronized与volatile]]></title>
    <url>%2F2018%2F02%2F11%2Fsynchronized-and-volatile%2F</url>
    <content type="text"><![CDATA[synchronized作用synchronized关键字用来执行线程间的互斥操作，从而达到同步的目的 原理synchronized使用了内部锁来保证了同一代码块同一时间只能被一个线程访问，原理如下所示： 123public synchronized void method() &#123; ... &#125; 相当于 123456789Lock lock = new ReentrantLock(); public void method() &#123; lock.lock(); try &#123; ... &#125;finally &#123; lock.unlock(); &#125; &#125; 又相当于 12345public void method() &#123; synchronized (this) &#123; ... &#125; &#125; 每个实例都拥有一个单独的锁，两个实例中的synchronized方法可以同时运行（注：静态方法则只能由一个线程运行） volatile作用使该修饰符修饰的变量发生变化时，变量的新值对其他线程时立即可见的 特征 volatile关键字不保证原子性 volatile关键字保证有序性和可见性 使用注意 对变量的写操作不会依赖当前值 该变量没有包含在具有其他变量的不变式中]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hashCode()和equals()]]></title>
    <url>%2F2018%2F02%2F11%2FHashCode-And-equal%2F</url>
    <content type="text"><![CDATA[equals作用equals的作用时判断两个对象是否相等 与”==”的比较“==”的作用是判断两个对象是否是同一个对象，例如b和c都是a的引用，则我们对b和c用==进行比较 1b == c; 所得到的结果为true，反之，如果两个并不是同一对象，即使两个对象是相等的，也会返回false 注意，在基本类型中，使用==即表示比较内容 要求Java对equals的要求为以下几点： 对称性：如果x.equals(y)返回是true，那么y.equals(x)也应该返回是true 自反性：x.equals(x)必须返回是true 传递性：如果x.equals(y)返回是true，而且y.equals(z)返回是true，那么z.equals(x)也应该返回是true 一致性：如果x.equals(y)返回是true，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是true 非空性：x.equals(null)，永远返回是false；x.equals(和x不同类型的对象)永远返回是false HashCode作用HashCode的作用是获得对象的Hash码，也叫做散列码，哈希码的作用是确定该对象在哈希表中的索引位置 也就是说，没有创建类对应的哈希表的情况下，HashCode并不起任何作用 与equals的比较HashCode与equals的比较仅仅在创建了类对应的哈希表的情况下才是有意义的，在这种情况下： 如果两个对象相等，则HashCode一定相等 如果两个对象的HashCode相等，则两个对象不一定相等 其中第二点就是发生了哈希冲突 要求 在一个Java应用的执行期间，如果一个对象提供给equals做比较的信息没有被修改的话，该对象多次调用hashCode()方法，该方法必须始终如一返回同一个integer。 如果两个对象根据equals(Object)方法是相等的，那么调用二者各自的hashCode()方法必须产生同一个integer结果。 并不要求根据equals(java.lang.Object)方法不相等的两个对象，调用二者各自的hashCode()方法必须产生不同的integer结果。然而，程序员应该意识到对于不同的对象产生不同的integer结果，有可能会提高hash table的性能。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用一个栈来实现另一个栈的排序]]></title>
    <url>%2F2018%2F02%2F10%2FsortStackByStack%2F</url>
    <content type="text"><![CDATA[解法： 将要排序的栈记为stack，申请的辅助栈记为help。在stack上执行pop操作，获得的元素记为cur 如果cur小于或等于help的栈顶元素，则将cur直接压入help 如果cur大于help的栈顶元素，则将help的元素逐一弹出，直到cur小于或等于help的栈顶元素 一直执行以上操作，直到stack的全部元素都压入到help，最后将help中的元素逐一压入stack，即完成排序 12345678910111213public static void sortStackByStack(Stack&lt;Integer&gt; stack) &#123; Stack&lt;Integer&gt; help = new Stack&lt;&gt;(); while (!stack.isEmpty()) &#123; int cur = stack.pop(); while (!help.isEmpty() &amp;&amp; help.peek() &lt; cur) &#123; stack.push(help.pop()); &#125; help.push(cur); &#125; while (!help.isEmpty()) &#123; stack.push(help.pop()); &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何仅用递归函数逆序一个栈]]></title>
    <url>%2F2018%2F02%2F09%2FreverseStack%2F</url>
    <content type="text"><![CDATA[使用递归函数逆序一个栈需要用到两次递归 解法递归函数一：将栈stack的栈底元素返回并移除12345678910public static int getAndRemoveLastElement(Stack&lt;Integer&gt; stack) &#123; int result = stack.pop(); if (stack.isEmpty()) &#123; return result; &#125; else &#123; int last = getAndRemoveLastElement(stack); stack.push(result); return last; &#125; &#125; 递归函数二：逆序一个栈12345678public static void reverse(Stack&lt;Integer&gt; stack) &#123; if (stack.isEmpty()) &#123; return; &#125; int i = getAndRemoveLastElement(stack); reverse(stack); stack.push(i); &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络分层及TCP、HTTP协议]]></title>
    <url>%2F2018%2F02%2F08%2FnetworkframeworkAndTCP%2F</url>
    <content type="text"><![CDATA[在Android中的网络编程中，我们需要了解基本的网络分层和最主要的几个协议 网络分层在我所学的《计算机网络》课本中，将网络分为物理层、数据链路层、网络层、传输层与应用层，这是一个自底而上的顺序，叫做五层协议体系模型；而在OSI七层体系模型中，则把应用层又分为了会话层、表示层与应用层，具体为： 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 TCP协议是属于传输层的协议，而HTTP协议在两个分层中都是属于应用层协议 TCP三次握手我们进行HTTP连接网络时会进行TCP的三次握手，然后传输数据，之后再释放连接，过程如下： 第一次握手：客户端向服务端发送SYN请求报文段，进入SYN_SENT状态 第二次握手：服务器收到客户端发来的SYN请求报文段，发送SYN+ACK报文段，进入SYN_REVD状态 第三次握手：客户端收到服务端的SYN+ACK报文段，向服务器发送ACK报文段，发送完毕后，客户端和服务器都进入ESTABLISHED状态 四次挥手建立连接后，当数据传送完毕，断开连接我们就需要进行四次挥手： 第一次挥手：客户端向服务端发送FIN报文段，进入FIN_WAIT_1状态，此时客户端已经没有数据需要发送给服务端了 第二次挥手：服务端收到了客户端发送的FIN报文段，向客户端发送ACK报文段 第三次挥手：服务端发送FIN报文段，进入LAST_ACK状态 第四次挥手：客户端收到服务端发送的FIN报文段，向服务端发送ACK报文段，服务端收到ACK报文后就关闭连接。客户端在等待最大报文生存时间后没有收到回复，客户端也关闭连接 HTTPHTTP是应用层的协议，它假定在下层的协议是可靠的，所以我们一般使用TCP/IP协议作为它的下层协议来使用 HTTP请求方法 GET：请求获取Request-URI所标识的资源 POST：在Request-URI所标识的资源后附加新的数据 HEAD：请求获取由Request-URI所标识的资源的相应消息报头 PUT：请求服务器存储一个资源，并用Request-URI作为其标识 DELETE：请求服务器删除Request-URI所标识的资源 TRACE：请求服务器回送收到的请求消息，用于测试或诊断 CONNECT：在1.1版本中将连接改为管道方式的代理服务器 OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求 HTTP响应状态码： 1XX：指示信息，收到请求，需要请求者继续执行操作 2XX：请求成功，请求已成功被处理 3XX：重定向，要完成请求必须进行更进一步的操作 4XX：客户端错误，请求有语法错误或无法实现 5XX：服务器错误，服务器不能实现合法的请求 HTTP消息报头HTTP消息报头又分为通用报头、请求报头、响应报头、实体报头等 通用报头 通用报头既可以出现在请求报头，也可以出现在响应报头中 Date：表示消息产生的日期和时间 Connection：允许发送指定连接的选项。 Cache-Control：用于指定缓存指令 请求报头 请求报头通知服务器关于客户端请求的信息 Host：请求的主机名，允许多个域名同处一个ip地址，即虚拟主机 User-Agent：发送请求的浏览器类型、操作系统等信息 Accept：客户端可识别的内容类型列表，用户指定客户端接收哪些类型的信息 Accept-Encoding：客户端可识别的数据编码 Accept-Language：表示浏览器支持的语言类型 Connection：允许客户端和服务器于指定与请求/响应连接有关的选项 Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式 响应报头 用于服务器传递自身信息的响应 Location：用于重定向接收者到一个新的位置，常用在更换域名的时候 Server：包含服务器用来处理请求的系统信息，与User-Agent请求报头是向对应的 实体报头 实体报头用来定义被传送资源的信息，其既可以用于请求也可以用于响应，请求和响应消息都可以传送一个实体 Content-Type：发送给接收者的实体正文的媒体类型 Content-Length：实体正文的长度 Content-Language：描述资源所用的自然语言 Content-Encoding：实体报头被用作媒体类型的修饰符 Last-Modified：实体报头用于只是资源的最后修改日期和时间 Expires：实体报头给出响应过期的日期和时间]]></content>
      <categories>
        <category>Android网络开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计一个有getMin功能的栈]]></title>
    <url>%2F2018%2F02%2F08%2FgetMinStack%2F</url>
    <content type="text"><![CDATA[题目为：实现一个特殊功能的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作 这个题目我们可以用两个栈来实现，有两种不同的解法 解法一 压入规则 假设当前数据为newNum，先将其压入stackData。然后判断stackMin是否为空： 如果为空，则newNum也压入stackMin 如果不为空，则比较newNum和stackMin的栈顶元素哪一个更小，如果相等或更小，则newNum也压入stackMin；如果stackMin中的栈顶元素小，则stackMin不压入任何内容 弹出规则 记stackMin的栈顶元素为value，当value等于stackMin的栈顶元素时，stackMin弹出栈顶元素；当value大于stackMin时，stackMin不弹出栈顶元素；返回value。 具体算法如下： 123456789101112131415161718192021222324252627282930313233343536public class MyStack1 &#123; private Stack&lt;Integer&gt; stackData; private Stack&lt;Integer&gt; stackMin; public MyStack1() &#123; stackData = new Stack&lt;&gt;(); stackMin = new Stack&lt;&gt;(); &#125; public void push(int newNum) &#123; if (stackMin.isEmpty()) &#123; stackMin.push(newNum); &#125; else if (newNum &lt;= getMin()) &#123; stackMin.push(newNum); &#125; stackData.push(newNum); &#125; public int pop() &#123; if (stackData.isEmpty()) &#123; throw new RuntimeException(&quot;Your stack is empty&quot;); &#125; int value = stackData.pop(); if (value == getMin()) &#123; stackMin.pop(); &#125; return value; &#125; public Integer getMin() &#123; if (stackMin.isEmpty()) &#123; throw new RuntimeException(&quot;Your stack is empty&quot;); &#125; return stackMin.peek(); &#125;&#125; 解法二：解法二与解法一不同的就是再压入时，如果newNum的值大于当前的最小值，则将最小值重复压入，弹出时同步弹出即可，不需要进行判断 具体算法如下： 123456789101112131415161718192021222324252627282930313233343536public class MyStack2 &#123; private Stack&lt;Integer&gt; stackData; private Stack&lt;Integer&gt; stackMin; public MyStack1() &#123; stackData = new Stack&lt;&gt;(); stackMin = new Stack&lt;&gt;(); &#125; public void push(int newNum) &#123; if (stackMin.isEmpty()) &#123; stackMin.push(newNum); &#125; else if (newNum &lt; getMin()) &#123; stackMin.push(newNum); &#125; else &#123; int newMin = stackMin.peek(); stackMin.push(newMin); &#125; stackData.push(newNum); &#125; public int pop() &#123; if (stackData.isEmpty()) &#123; throw new RuntimeException(&quot;Your stack is empty&quot;); &#125; stackMin.pop(); return stackData.pop(); &#125; public Integer getMin() &#123; if (stackMin.isEmpty()) &#123; throw new RuntimeException(&quot;Your stack is empty&quot;); &#125; return stackMin.peek(); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[不用任何比较判断找出两个数中较大的数]]></title>
    <url>%2F2018%2F02%2F07%2FgetMax%2F</url>
    <content type="text"><![CDATA[题目：给定两个32位整数a和b，返回a和b中较大的数，不用任何比较判断 解法我们使用位运算来解决这个问题，具体思路如下： a和b的符号不同，则有以下两种情况 a为0或正，那么b为负，返回a 如果a为负，则b为正或0，返回b a和b的符号相同，a-b的值绝对不会溢出 如果a-b为0或正，返回a 如果a-b为负，返回b 具体算法如下： 1234567891011121314151617public int flip(int n) &#123; return n ^ 1; &#125; public int sign(int n) &#123; return flip((n &gt;&gt; 31) &amp; 1); &#125; public int getMax2(int a, int b) &#123; int c = a - b; int sa = sign(a); int sb = sign(b); int sc = sign(c); int difSab = sa ^ sb; int sameSab = flip(difSab); int returnA = difSab * sa + sameSab * sc; int returnB = flip(returnA); return a * returnA + b * returnB; &#125; 其中函数sign的作用是返回整数n的符号，正数和0返回1，负数则返回0。flip函数的功能是如果n为1，返回0，如果n为0，返回1。]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中的网络通信]]></title>
    <url>%2F2018%2F02%2F06%2FJava%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[Java在编程开发中经常用来构建一些大型的web应用，网络通信是必不可少的，而网络通信就涉及到以下几个必备的知识点 网络通信预备知识点TCP/IP协议TCP/IP协议中文译名为传输控制协议/互联网协议，是Internet最基本的协议。 IP协议规定了数据传输时的基本单元和格式，还规定了数据包的提交方法和路由选择。 TCP协议则提供了可靠的面向对象的数据流传输服务的规则和约定，简单地说就是，当一方向另一方发送一个数据包时，收到数据包的一方需要发送一个确认数据包给发送数据包的一方。 URLURL是Uniform Resource Locator的缩写，称为网页地址，是因特网上标准的资源的地址，Internet上的每一个网页都具有一个唯一的名称标识，通常称之为URL地址，这种地址可以是本地磁盘，也可以是局域网上的某一台计算机，更多的是Internet上的站点。 Socket和ServerSocket概述Socket又称套接字，应用程序通常通过套接字向网络发出请求或者应答网络请求。 在Java中，Socket和ServerSocket类库位于java.net包中，ServerSocket用于服务器端，Socket是建立网络连接时使用的。在连接成功时，应用程序俩端都会产生一个Socket实例，操作这个实例，完成所需的会话。两端所产生的Socket实例都是相等的，并没有差别。Socket的工作过程包括以下4个基本步骤： 创建Socket 打开连接到Socket的输入/输出流 进行通信 关闭Socket Socket使用TCP协议，适用于建立长时间连接，通常应用于实时通信 实例这里举例一个客户端与服务器端相互通信的例子 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Client &#123; public static final int port = 8080; public static final String host = &quot;localhost&quot;; public static void main(String[] args) &#123; System.out.println(&quot;Client Start...&quot;); while (true) &#123; Socket socket = null; try &#123; //创建一个流套接字并将其连接到指定主机上的指定端口号 socket = new Socket(host,port); //读取服务器端数据 BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream())); //向服务器端发送数据 PrintStream out = new PrintStream(socket.getOutputStream()); System.out.print(&quot;请输入: \t&quot;); String str = new BufferedReader(new InputStreamReader(System.in)).readLine(); out.println(str); String ret = input.readLine(); System.out.println(&quot;服务器端返回过来的是: &quot; + ret); // 如接收到 &quot;OK&quot; 则断开连接 if (&quot;OK&quot;.equals(ret)) &#123; System.out.println(&quot;客户端将关闭连接&quot;); Thread.sleep(500); break; &#125; out.close(); input.close(); &#125; catch (Exception e) &#123; System.out.println(&quot;客户端异常:&quot; + e.getMessage()); &#125; finally &#123; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; socket = null; System.out.println(&quot;客户端 finally 异常:&quot; + e.getMessage()); &#125; &#125; &#125; &#125; &#125;&#125; 服务端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Server &#123; public static final int port = 8080;//监听的端口号 public static void main(String[] args) &#123; System.out.println(&quot;Server...\n&quot;); Server server = new Server(); server.init(); &#125; public void init() &#123; try &#123; //创建一个ServerSocket，这里可以指定连接请求的队列长度 //new ServerSocket(port,3);意味着当队列中有3个连接请求是，如果Client再请求连接，就会被Server拒绝 ServerSocket serverSocket = new ServerSocket(port); while (true) &#123; //从请求队列中取出一个连接 Socket client = serverSocket.accept(); // 处理这次连接 new HandlerThread(client); &#125; &#125; catch (Exception e) &#123; System.out.println(&quot;服务器异常: &quot; + e.getMessage()); &#125; &#125; private class HandlerThread implements Runnable &#123; private Socket socket; public HandlerThread(Socket client) &#123; socket = client; new Thread(this).start(); &#125; public void run() &#123; try &#123; // 读取客户端数据 BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream())); String clientInputStr = input.readLine();//这里要注意和客户端输出流的写方法对应,否则会抛 EOFException // 处理客户端数据 System.out.println(&quot;客户端发过来的内容:&quot; + clientInputStr); // 向客户端回复信息 PrintStream out = new PrintStream(socket.getOutputStream()); System.out.print(&quot;请输入:\t&quot;); // 发送键盘输入的一行 String s = new BufferedReader(new InputStreamReader(System.in)).readLine(); out.println(s); out.close(); input.close(); &#125; catch (Exception e) &#123; System.out.println(&quot;服务器 run 异常: &quot; + e.getMessage()); &#125; finally &#123; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (Exception e) &#123; socket = null; System.out.println(&quot;服务端 finally 异常:&quot; + e.getMessage()); &#125; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android网络开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[按照左右半区的方式重新组合单链表]]></title>
    <url>%2F2018%2F02%2F06%2Frelocate%2F</url>
    <content type="text"><![CDATA[这道题的题目有些复杂，是这样的：给定一个单链表的头部节点head，链表长度为N，如果N为偶数，那么前N/2个算作左半区，后N/2个节点算作右半区；如果N为奇数，那么前N/2个节点算作左半区，后N/2个节点算作右半区。左半区从左到右即为L1-&gt;L2-&gt;…，右半区从左到右记为R1-&gt;R2-&gt;…,将单链表调整为L1-&gt;R1-&gt;L2-&gt;R2-&gt;…的形式。 解法 解题思路如下： 如果链表为空或长度为1，不用调整，过程直接结束 链表长度大于1时，遍历一遍找到左半区的最后一个节点，记为mid 遍历一遍找到mid之后，将左半区与右半区分离成两个链表（mid.next=null),分别记为left(head)和right（原来的mid.next) 将两个链表按照题目要求合并起来 算法如下： 12345678910111213141516171819202122232425public void relocate(Node head) &#123; if (head == null || head.next == null) &#123; return; &#125; Node mid = head; Node right = head.next; while (right.next != null &amp;&amp; right.next.next != null) &#123; mid = mid.next; right = right.next.next; &#125; right = mid.next; mid.next = null; merge(head, right); &#125; public void mergeLR(Node left, Node right) &#123; Node next = null; while (left.next != null) &#123; next = right.next; right.next = left.next; left.next = right; left = right.next; right = next; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[合并两个有序的单链表]]></title>
    <url>%2F2018%2F02%2F04%2Fmerge%2F</url>
    <content type="text"><![CDATA[给定两个有序单链表的头节点head1和head2，合并两个有序链表，合并后的链表依然有序，并放回头节点 解法本题比较简单，但思路需要理顺的，具体如下： 如果两个链表中有一个为空，说明无须合并过程，返回另一个链表的头节点即可 比较head1和head2的值，小的节点也是链表合并后的第一个节点，记为head 设head节点所在的链表为链表1，另一个链表为链表2。链表1和链表2都从头部开始一起遍历，比较每次遍历到的两个节点的值，记为cur1和cur2，然后根据大小关系做出不同的调整，同时用一个变量pre表示上次比较时值较小的节点。 如果链表1先走完，此时cur1=null，pre为链表1的最后一个节点，那么就把pre的next指针指向链表2当前的节点，表示把链表2没遍历到的有序部分直接拼接到最后，调整结束。如果链表2先走完，说明链表2的所有节点都已经插入到链表1中，调整结束 返回合并后链表的头节点head 具体算法如下： 123456789101112131415161718192021222324public Node merge(Node head1, Node head2) &#123; if (head1 == null || head2 == null) &#123; return head1 != null ? head1 : head2; &#125; Node head = head1.value &lt; head2.value ? head1 : head2; Node cur1 = head == head1 ? head1 : head2; Node cur2 = head == head1 ? head2 : head1; Node pre = null; Node next = null; while (cur1 != null &amp;&amp; cur2 != null) &#123; if (cur1.value &lt;= cur2.value) &#123; pre = cur1; cur1 = cur1.next; &#125; else &#123; next = cur2.next; pre.next = cur2; cur2.next = cur1; pre = cur2; cur2 = next; &#125; &#125; pre.next = cur1 == null ? cur2 : cur1; return head; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在有序的环型单链表中插入新节点]]></title>
    <url>%2F2018%2F02%2F02%2FinawetNum%2F</url>
    <content type="text"><![CDATA[若一个环型链表从head开始不降序，同时由最后的节点返回头节点，将节点值为num的节点插入到有序链表中，插入后链表仍然有序 解法思路如下： 生成节点值为num的节点，记为node 如果链表为空，让node自己组成环型链表，然后直接返回node 如果链表不为空，令变量pre=head，cur=head.next，然后令pre和next移动，如果遇到num的值正好在pre和next之间，就进行插入 如果没有遇到3的情况，就插入到head节点的之前一个节点 如果node节点的值大于头节点，则返回头节点，否则则返回node节点 具体算法如下： 12345678910111213141516171819public Node insertNOde(Node head, int num) &#123; Node node = new Node(num); if (head == null) &#123; node.next = node; return node; &#125; Node pre = head; Node cur = head.next; while (cur != null) &#123; if (pre.value &lt;= num &amp;&amp; cur.value &gt;= num) &#123; break; &#125; pre = cur; cur = cur.next; &#125; pre.next = node; node.next = cur; return head.value &lt; num ? head : node; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[将搜索二叉树转换成双向链表]]></title>
    <url>%2F2018%2F01%2F31%2Fconvert%2F</url>
    <content type="text"><![CDATA[二叉树的节点有本身的值域，有指向左孩子和右孩子的两个指针；对双向链表来说，有本身的值域，有指向上一个节点和下一个节点的指针。在结构上，结构有相似性，现在有一颗搜索二叉树，将其转换成一个有序的双向链表有两种方法：第一种是使用队列收集遍历结果，另一种则是利用递归函数。 方法一：用队列等容器收集二叉树中中序遍历结果的方法思路如下： 生成一个队列，记为queue，按照二叉树中中序遍历的顺序，将每个节点放入queue中 从queue中依次弹出节点，并按照弹出的顺序重连所有的节点即可 代码如下： 12345678910111213141516171819202122232425262728public Node convert1(Node head) &#123; Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); inOrderToQueue(head, queue); if (queue.isEmpty()) &#123; return head; &#125; head = queue.poll(); Node pre = head; pre.left = null; Node cur = null; while (!queue.isEmpty()) &#123; cur = queue.poll(); pre.right = cur; cur.left = pre; pre = cur; &#125; pre.right = null; return head; &#125; public void inOrderToQueue(Node head, Queue&lt;Node&gt; queue) &#123; if (head == null) &#123; return; &#125; inOrderToQueue(head.left, queue); queue.offer(head); inOrderToQueue(head.right, queue); &#125; 方法二：利用递归函数，除此之外不适用任何容器的方法这个解法比方法一要复杂一些，过程如下： 实现递归函数precess。precess的功能是将一棵搜索二叉树转换为一个结构有点特殊的有序双向链表，特殊结构是指这个双向链表尾节点的right指针指向该双向链表的头节点 通过process过程得到的双向链表是尾节点的right指针连向头节点的结构，所以，最终需要将尾节点的right指着你设置为null 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940public Node convert2(Node head) &#123; if (head == null) &#123; return null; &#125; Node last = process(head); head = last.right; last.right = null; return head; &#125; public Node process(Node head) &#123; if (head == null) &#123; return null; &#125; Node leftE = process(head.left); Node rightE = process(head.right); Node leftS = leftE != null ? leftE.right : null; Node rightS = rightE != null ? rightE.right : null; if (leftE != null &amp;&amp; rightE != null) &#123; leftE.right = head; head.right = rightE; head.left = leftE; rightS.left = head; rightE.right = leftS; return rightE; &#125; else if (leftE != null)&#123; leftE.right = head; head.left = leftE; head.right = leftS; return head; &#125; else if(rightE != null) &#123; head.right = rightS; rightS.left = head; rightE.right = head; return rightE; &#125; else &#123; head.right = head; return head; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在单链表中删除指定值的节点]]></title>
    <url>%2F2018%2F01%2F30%2FremoveValue%2F</url>
    <content type="text"><![CDATA[这个题也有两种解法，一种是利用栈结构，另一种则是直接调整 方法一：利用栈结构或其他容器收集节点思路：将值不等于num的节点用栈收集起来，收集完成后重新连接即可。最后将栈底的节点作为新的头节点返回 算法如下： 1234567891011121314public Node removeValue1(Node head, int num) &#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); while (head != null) &#123; if (head.value != num) &#123; stack.push(head); &#125; head = head.next; &#125; while (!stack.isEmpty()) &#123; stack.peek().next = head; head = stack.pop(); &#125; return head; &#125; 方法二：不用任何容器而直接调整的方法思路：首先从链表头开始，找到第一个值不等于num的节点，作为新的头节点，这个节点是肯定不用删除的，记为newHead，继续往后遍历，假设当前节点为cur，如果cur节点值等于num，就将cur节点删除，删除的方法是将之前最近一个值不等于num的节点pre连接到cur的下一个节点，即pre.next=cur.next；如果cur节点的值不等于num，就令pre=cur，即更新最近一个值不等于num的节点 算法如下： 1234567891011121314public Node removeValue1(Node head, int num) &#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); while (head != null) &#123; if (head.value != num) &#123; stack.push(head); &#125; head = head.next; &#125; while (!stack.isEmpty()) &#123; stack.peek().next = head; head = stack.pop(); &#125; return head; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[删除无序单链表中重复出现的节点]]></title>
    <url>%2F2018%2F01%2F29%2FdeletePoint%2F</url>
    <content type="text"><![CDATA[此题目要求的是将重复值的节点删去，也就是说在链表中，同一个值只能有一个节点，这道题有两种解法，一种是利用哈希表，另一种则是先选择排序，然后再进行删除 方法一：利用哈希表具体过程如下： 生成一个哈希表，因为头节点是不用删除的节点，所以将头节点的值放入哈希表 从头节点的下一个节点开始往后遍历节点，假设当前遍历到cur节点，先检查cur的值是否再哈希表中，如果再，则说明cur节点的值是之前出现过的，就将cur节点删除，删除的方式是将最近一个没有被删除的节点pre连接到cur的下一个节点，即pre.next=cur.next。如果不在，将cur节点的值放入哈希表，同时令pre=cur，即更新最近一个没有被删除的节点 算法如下： 123456789101112131415161718public void removeRep1(Node head) &#123; if (head == null) &#123; return; &#125; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); Node pre = head; Node cur = head.next; set.add(head.value); while (cur != null) &#123; if (set.contains(cur.value)) &#123; pre.next = cur.next; &#125; else &#123; set.add(cur.value); pre = cur; &#125; cur = cur.next; &#125; &#125; 方法二：类似选择排序的过程 注意：这道题是基于已排序好的链表上的 具体思路为：获得第一个新值，然后往后检查所有值为此值的节点全部删除 123456789101112131415161718public void removeRep2(Node head) &#123; Node cur = head; Node pre = null; Node next = null; while (cur != null) &#123; pre = cur; next = cur.next; while (next != null) &#123; if (cur.value == next.value) &#123; pre.next = next.next; &#125; else &#123; pre = next; &#125; next = next.next; &#125; cur = cur.next; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式的目标-面向对象的六大原则]]></title>
    <url>%2F2018%2F01%2F28%2Foopsix%2F</url>
    <content type="text"><![CDATA[设计模式有六大原则，分别时单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、迪米特原则和接口隔离原则，这些原则是设计模式的最终目标，不过并不是每一个设计模式都遵循了以上六个原则 单一职责原则定义：就一个类而言，应该仅有一个引起它变化的原因单一职责原则的划分界限并不是总是那么清晰，很多时候都需要依赖个人经验来界定，最大的问题就是对职责的定义，什么是类的职责，以及怎么划分类的职责。 一个类中应该是一组相关性很高的函数、数据的封装。 开放封闭原则定义：类、模块、函数等应该是可以扩展的，但是不可修改在软件开发过程中，最不会变化的就是变化本身，因为产品需要不断地升级、维护，而在这个过程中修改原来的代码就可能会引发其他的问题，所以，开闭原则的使用在这里就十分重要。 开闭原则主要是通过接口来实现，而不能是具体的类，下面举一个简单的例子。 接口类 1234public interface ImageCache &#123; Bitmap get(String url); void put(String url, Bitmap bitmap);&#125; 接口实现类 1234567891011public class StoreCache implements ImageCache &#123; @Override public Bitmap get(String url) &#123; return new Bitmap(); &#125; @Override public void put(String url, Bitmap bitmap) &#123; System.out.println(&quot;put image&quot;); &#125;&#125; 依赖类 123public class ImageLoader &#123; ImageCache imageCache = new StoreCache();&#125; 在这个例子当中，ImageLoader类依赖于ImageCache接口，而不是依赖于具体的实现ImageCache接口的类，这样我们可以方便地进行扩展（继承ImageCache接口的类），而不是直接修改代码 里氏替换原则定义：所有引用基类的地方必须能透明地使用其子类的对象里氏替换原则简单来说就是父类出现的地方，替换成子类不会产生任何错误或异常，但是子类出现的地方，替换成父类就不一定能够适应，其实就是抽象的概念 可以举一个Android中View的例子 View：抽象父类 12345public abstract class View &#123; public abstract void draw(); public void measure(int width, int height)&#123; &#125;&#125; Button:具体子类 12345public class Button extends View&#123; @Override public void draw() &#123; &#125;&#125; 窗口类 12345public class Window&#123; public void show(View child)&#123; child.draw(); &#125;&#125; 我们可以看到，窗口类中所使用的View类均可以无副作用地替换成Button子类 依赖倒置原则定义：高层模块不应该依赖底层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象依赖倒置原则就是在类中不应该依赖具体的类，而是应该依赖于抽象，具体的例子其实在开闭原则中已经有了，关键就在于以下代码 1ImageCache imageCache = new StoreCache(); 迪米特原则定义：一个软件实体应当尽可能少地与其他实体发生相互作用如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法，则可以通过第三者转发这个调用，简言之，就是引入一个合理的第三者来降低现有对象之间的耦合度 接口隔离原则定义：一个类对另一个类的依赖应该建立在最小的接口上接口原则说白了就是，客户端依赖的接口经可能地小，臃肿的接口拆分成更小的和更具体的接口，在实际的运用当中就是：将一个包含有多个函数的接口拆分成多个，将函数一分为几，被分到同一接口的函数职责更为单一。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[将单链表的每K个节点之间逆序]]></title>
    <url>%2F2018%2F01%2F28%2FreverseKNodes%2F</url>
    <content type="text"><![CDATA[这道题也有两种解法，一种是使用了栈结构，而另一种则不需要 方法一：使用栈结构使用栈结构的方法思路如下： 从左到右遍历链表，如果栈的大小不等于K，就将接地啊年不断压入栈中 当栈的大小第一次到达K时，说明第一次凑齐了K个节点进行逆序，从栈中一次弹出这些节点，并根据弹出的顺序重新连接，这一组逆序完成后，需要记录一下新的头部，同时第一组的最后一个节点应该连接下一个节点 步骤2之后，当栈的大小每次到达K时，说明又凑齐了一组应该进行逆序的节点，从栈中一次弹出这些节点，并根据弹出的顺序重新连接，这一组逆序完成后，该组的第一个节点应该被上一组的最后一个节点连接上，这一组的最后一个节点应该连接下一个节点，然后继续去凑下一组，知道链表都被遍历完 最后应该返回newHead，作为链表新的头节点 具体算法如下： 12345678910111213141516171819202122232425262728293031323334public Node reverseKNodes1(Node head, int K) &#123; if (K &lt; 2) &#123; return head; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node newHead = head; Node cur = head; Node pre = null; Node next = null; while (cur != null) &#123; next = cur.next; stack.push(cur); if (stack.size() == K) &#123; pre = resign1(stack, pre, next); newHead = newHead == head ? cur :newHead; &#125; cur = next; &#125; return newHead; &#125; public Node resign1(Stack&lt;Node&gt; stack, Node left, Node right) &#123; Node cur = stack.pop(); if (left != null) &#123; left.next = cur; &#125; Node next = null; while (!stack.isEmpty()) &#123; next = stack.pop(); cur.next = next; cur = next; &#125; cur.next = right; return cur; &#125; 方法二：不需要栈结构，在原链表中直接调整思路如下：用变量记录每一组的第一个节点和最后一个节点，然后直接逆序调整，把这一组的节点都逆序。和方法一一样，同样需要注意第一组节点的特殊处理，以及之后的每一个组在逆序重连之后，需要让该组的第一个节点被之前组的最后一个节点连接上，将该组的最后一个节点连接下一个节点 具体算法如下： 123456789101112131415161718192021222324252627282930313233343536373839public Node reverseKNodes2(Node head, int K) &#123; if (K &lt; 2) &#123; return head; &#125; Node cur = head; Node start = null; Node pre = null; Node next = null; int count = 1; while (cur != null) &#123; next = cur.next; if (count == K) &#123; start = pre == null ? head :pre.next; head = pre == null ? cur : head; resign2(pre, start, cur, next); pre = start; count = 0; &#125; count ++; cur = next; &#125; return head; &#125; public void resign2(Node left, Node start, Node end, Node right) &#123; Node pre = start; Node cur = start.next; Node next = null; while (cur != right) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; if (left != null) &#123; left.next = end; &#125; start.next = right; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[两个单链表生成相加链表]]></title>
    <url>%2F2018%2F01%2F27%2Ftwolianbiaotoone%2F</url>
    <content type="text"><![CDATA[题目这道题的题目时这样的，两个链表都代表一个整数，如9-&gt;3-&gt;7代表整数937，6-&gt;3代表整数63，则两个链表相加则为1-&gt;0-&gt;0-&gt;0 方法一：利用栈求解思路如下： 将两个链表分别从头到尾进行遍历，遍历过程中将值压栈，这样就生成了两个逆序栈s1和s2 将s1和s2同步弹出，这样就相当于两个链表从低位到高位依次弹出，在这个过程中生成相加链表即可，同时需要关注每一步是否有进位，用ca表示 当s1和s2都为空时，还要关注一下进位信息是否为1，如果为1，则表示还要生成一个节点值为1的新节点 返回新生成的结果 具体算法如下 123456789101112131415161718192021222324252627282930313233public Node addLists1(Node head1, Node head2) &#123; Stack&lt;Integer&gt; s1 = new Stack&lt;&gt;(); Stack&lt;Integer&gt; s2 = new Stack&lt;&gt;(); while (head1 != null) &#123; s1.push(head1.value); head1 = head1.next; &#125; while (head2 != null) &#123; s2.push(head2.value); head2 = head2.next; &#125; int ca = 0; int n1 = 0; int n2 = 0; int n = 0; Node node = null; Node pre = null; while (!s1.isEmpty() || !s2.isEmpty()) &#123; n1 = s1.isEmpty()? 0 : s1.pop(); n2 = s2.isEmpty()? 0 : s2.pop(); n = n1 + n2 + ca; pre = node; node = new Node(n % 10); node.next = pre; ca = n /10; &#125; if (ca == 1) &#123; pre = node; node = new Node(1); node.next = pre; &#125; return node; &#125; 方法二：利用链表的逆序求解这个方法比方法1省去了用栈的空间，具体思路如下： 将两个链表逆序，这样就可以依次得到从低位到高位的数字 同步遍历两个逆序后的链表，这样就依次得到两个链表从低位到高位的数字，在这个过程中生成相加链表即可，同时需要关注每一步是否有进位，用ca表示 两个链表都遍历完成后，还要关注进位信息是否为1，如果为1，还要生成一个节点值为1的新节点 将两个逆序的链表再逆序一次，即调整成原来的样子 返回新生成的结果链表 算法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243public Node addLists2(Node head1, Node head2) &#123; head1 = reverse(head1); head2 = reverse(head2); int ca = 0; int n1 = 0; int n2 = 0; int n = 0; Node c1 = head1; Node c2 = head2; Node node = null; Node pre = null; while (c1 != null || c2 != null) &#123; n1 = c1 != null ? c1.value : 0; n2 = c2 != null ? c2.value : 0; n = n1 + n2 + ca; pre = node; node = new Node(n % 10); node.next = pre; ca = n / 10; c1 = c1 != null ? c1.next :null; c2 = c2 != null ? c2.next :null; &#125; if (ca == 1) &#123; pre = node; node = new Node(1); node.next = pre; &#125; reverse(head1); reverse(head2); return pre; &#125; public Node reverse(Node head) &#123; Node pre = null; Node next = null; while (head != null) &#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[抽象与实现之间的桥梁-桥接模式]]></title>
    <url>%2F2018%2F01%2F26%2F%E6%8A%BD%E8%B1%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%A1%A5%E6%A2%81-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[桥梁的作用其实就是连接“抽象部分”与“实现部分”，任何多维度变化类或者说树状类之间的耦合都可以使用桥接模式来进行解耦 生活中桥接模式也十分地常见，例如咖啡的种类，电源插头的使用等等，这里就举一个咖啡的例子，由它来实现桥接模式 咖啡与糖的关系是多对多的，我们需要先建立咖啡与糖的抽象类，咖啡抽象类依赖糖的抽象类 糖抽象类123public abstract class CoffeeAdditives &#123; public abstract String addSomething();&#125; 糖具体类 加糖 123456public class Sugar extends CoffeeAdditives &#123; @Override public String addSomething() &#123; return &quot;add sugar&quot;; &#125;&#125; 不加糖 123456public class Ordinary extends CoffeeAdditives &#123; @Override public String addSomething() &#123; return &quot;ordinary&quot;; &#125;&#125; 咖啡抽象类12345678public abstract class Coffee &#123; protected CoffeeAdditives coffeeAdditives; public Coffee(CoffeeAdditives coffeeAdditives) &#123; this.coffeeAdditives = coffeeAdditives; &#125; public abstract void makeCoffee();&#125; 具体咖啡类 大杯咖啡 12345678910public class LargeCoffee extends Coffee &#123; public LargeCoffee(CoffeeAdditives coffeeAdditives) &#123; super(coffeeAdditives); &#125; @Override public void makeCoffee() &#123; System.out.println(&quot;large &quot; + coffeeAdditives.addSomething() + &quot; coffee&quot;); &#125;&#125; 小杯咖啡 12345678910public class SmallCoffee extends Coffee &#123; public SmallCoffee(CoffeeAdditives coffeeAdditives) &#123; super(coffeeAdditives); &#125; @Override public void makeCoffee() &#123; System.out.println(&quot;small &quot; + coffeeAdditives.addSomething() + &quot; coffee&quot;); &#125;&#125; 使用如下12345678910public class Main &#123; public static void main(String[] args) &#123; Ordinary ordinary = new Ordinary(); Sugar sugar = new Sugar(); LargeCoffee largeCoffee = new LargeCoffee(ordinary); largeCoffee.makeCoffee(); SmallCoffee smallCoffee = new SmallCoffee(sugar); smallCoffee.makeCoffee(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[复制含有随机指针的链表]]></title>
    <url>%2F2018%2F01%2F26%2F%E5%A4%8D%E5%88%B6%E5%90%AB%E6%9C%89%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[带随机指针的节点是一种特殊的数据结构，它的结构如下 123456789public class Node &#123; public Node next; public int value; public Node rand; public Node(int data) &#123; this.value = data; &#125;&#125; 普通解法思路： 从头到尾遍历链表，每个节电都复制生成相应的副本节点，然后将对应关系放入哈希表map中 第二次从左到右遍历链表，设置每一个节点的next和rand指针 将第一个节点返回 具体算法如下： 123456789101112131415public Node copyListWithRand1(Node head) &#123; HashMap&lt;Node, Node&gt; map = new HashMap&lt;&gt;(); Node cur = head; while (cur != null) &#123; map.put(cur, new Node(cur.value)); cur = cur.next; &#125; cur = head; while (cur != null) &#123; map.get(cur).next = map.get(cur.next); map.get(cur).rand = map.get(cur.rand); cur = cur.next; &#125; return map.get(head); &#125; 进阶解法 进阶解法不适用哈希表map，仅仅使用有限几个变量 思路如下： 从头到尾遍历链表，对每个节点cur都复制生成相应的副本节点copy，然后把copy放在cur和下一届要遍历的节点的中间 第二次遍历链表，在遍历时设置每一个节点的rand指针 分离节点与副本节点 将第一个节点返回 算法如下： 12345678910111213141516171819202122232425262728293031public Node copyListWithRand2(Node head) &#123; if (head == null) &#123; return null; &#125; Node cur = head; Node next = null; while (cur != null) &#123; next = cur.next; cur.next = new Node(cur.value); cur.next.next = next; cur = next; &#125; cur = head; Node curCopy = null; while (cur != null) &#123; next = cur.next.next; curCopy = cur.next; curCopy.rand = cur.rand!= null? cur.rand.next :null; cur = next; &#125; Node res = head.next; cur = head; while (cur != null) &#123; next = cur.next.next; curCopy = cur.next; cur.next = next; curCopy.next = next != null?next.next :null; cur =next; &#125; return res; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[打印两个有序链表的公共部分]]></title>
    <url>%2F2018%2F01%2F25%2F%E6%89%93%E5%8D%B0%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AC%E5%85%B1%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[打印两个有序链表的公共部分，思路如下： 若head1的值大于head2，则head2移动到下一节点，反之head1移动 若head1的值等于head2的值，则找到公共部分，开始打印 ##### 具体算法如下： 12345678910111213public void printCommonPart(Node head1, Node head2) &#123; while (head1 != null &amp;&amp; head2 != null) &#123; if (head1.value &gt; head2.value) &#123; head2 = head2.next; &#125;else if(head1.value &lt; head2.value) &#123; head1 = head1.next; &#125;else &#123; System.out.print(head1.value + &quot; &quot;); head1 = head1.next; head2 = head2.next; &#125; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[轻量级的对象池-享元模式]]></title>
    <url>%2F2018%2F01%2F25%2F%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[享元模式又称Flyweight，代表轻量级的意思，适用于可能存在大量可重复对象的场景 这里举一个售卖火车票的例子 共享对象的接口，这里是火车票接口123public interface Ticket &#123; void showTicketInfo(String bunk);&#125; 具体对象类123456789101112131415public class TrainTicket implements Ticket &#123; public String from; public String to; public String bunk; public int price; public TrainTicket(String from, String to) &#123; this.from = from; this.to = to; price = new Random().nextInt(300); &#125; @Override public void showTicketInfo(String bunk) &#123; System.out.println(from + &quot;到&quot; + to + &quot;的&quot; + bunk +&quot;火车票价格：&quot; + price); &#125;&#125; 对象生产工厂12345678910111213public class TickFactory &#123; static Map&lt;String, Ticket&gt; stringTicketMap = new ConcurrentHashMap&lt;&gt;(); public static Ticket getTicket(String from, String to) &#123; String key = from + &quot;-&quot; + to; if (stringTicketMap.containsKey(key)) &#123; return stringTicketMap.get(key); &#125; else &#123; Ticket ticket =new TrainTicket(from, to); stringTicketMap.put(from + &quot;-&quot; + to,ticket); return ticket; &#125; &#125;&#125; 在这里我们使用了一个map来存放已经存在的对象，这也是享元模式的关键，这样就不用每次都重新创建对象，减少内存的消耗 使用如下 12345678910public class Main &#123; public static void main(String[] args) &#123; Ticket ticket = TickFactory.getTicket(&quot;长兴&quot;, &quot;武汉&quot;); ticket.showTicketInfo(&quot;上铺&quot;); Ticket ticket1 = TickFactory.getTicket(&quot;武汉&quot;, &quot;长兴&quot;); ticket1.showTicketInfo(&quot;软卧&quot;); Ticket ticket2 = TickFactory.getTicket(&quot;长兴&quot;, &quot;武汉&quot;); ticket2.showTicketInfo(&quot;上铺&quot;); &#125;&#125; 结果]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[将单向链表按某值划分成左边小、中间相等、右边大的形式]]></title>
    <url>%2F2018%2F01%2F25%2F%E5%B0%86%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%8C%89%E6%9F%90%E5%80%BC%E5%88%92%E5%88%86%E4%B8%BA%E5%B7%A6%E5%B0%8F%E4%B8%AD%E7%AD%89%E5%8F%B3%E5%A4%A7%E7%9A%84%E5%BD%A2%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本题也有两种解法，一种普通解法一种进阶解法，进阶解法多出了额外空间复杂度的要求 普通解法普通解法的思路如下 遍历链表，得到长度N 生成长度为N的Node类型的数组nodeArr，遍历链表，依次将节点放入 在nodeArr中把小于pivot的节点放在左边，相等的放中间，大于的放右边 结果步骤3的调整后，再把nodeArr中的节点依次连起来 具体算法如下：12345678910111213141516171819202122232425262728293031323334353637383940414243public Node listPartition1(Node head, int pivot) &#123; if (head == null) &#123; return head; &#125; Node cur = head; int i =0; while (cur != null) &#123; i ++; cur = cur.next; &#125; Node[] nodeArr = new Node[i]; i = 0; cur =head; for (i = 0; i != nodeArr.length; i++)&#123; nodeArr[i] = cur; cur = cur.next; &#125; arrPartition(nodeArr,pivot); for(i = 1; i != nodeArr.length; i++) &#123; nodeArr[i -1].next = nodeArr[i]; &#125; nodeArr[i-1].next = null; return nodeArr[0]; &#125; public void arrPartition(Node[] nodeArr, int pivot) &#123; int small = -1; int big = nodeArr.length; int index = 0; while (index != big) &#123; if (nodeArr[index].value &lt; pivot) &#123; swap(nodeArr, ++small, index++); &#125;else if (nodeArr[index].value == pivot) &#123; index ++; &#125;else &#123; swap(nodeArr, -- big, index); &#125; &#125; &#125; public void swap(Node[] nodeArr, int a, int b) &#123; Node tmp = nodeArr[a]; nodeArr[a] = nodeArr[b]; nodeArr[b] = tmp; &#125; 进阶解法进阶解法当中没有用到普通解法中的排序，而是将所有节点依次分为三个链表，完成之后再进行连接 分为small、equal、big三个链表 将small、equal和big三个链表重新串起来即可 整个过程需要特别注意对null节点的判断和处理 具体算法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public Node listPartition2(Node head, int pivot) &#123; Node sH = null; Node sT = null; Node eH = null; Node eT = null; Node bH = null; Node bT = null; Node next = null; while (head != null) &#123; next = head.next; head.next = null; if (head.value &lt; pivot) &#123; if (sH == null) &#123; sH = head; sT =head; &#125; else &#123; sT.next = head; sT = head; &#125; &#125; else if (head.value == pivot) &#123; if (eH == null) &#123; eH = head; eT = head; &#125;else &#123; eT.next = head; eT = head; &#125; &#125;else &#123; if (bH == null) &#123; bH = head; bT = head; &#125; else &#123; bT.next = head; bT = head; &#125; &#125; head = next; &#125; if (sT != null) &#123; sT.next = eH; eT = eT == null?sT :eT; &#125; if (eT != null) &#123; eT.next =bH; &#125; return sH != null?sH:eH!=null?eH:bH; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用最频繁的粘合剂-适配器模式]]></title>
    <url>%2F2018%2F01%2F24%2F%E4%BD%BF%E7%94%A8%E6%9C%80%E9%A2%91%E7%B9%81%E7%9A%84%E7%B2%98%E5%90%88%E5%89%82-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[适配器模式可以说是开发Android过程中绕不开的一个设计模式，ListView到RecyclerVIew都需要使用适配器模式，相当于将两个类粘合在一起，这个模式在我们的生活中也能见到类似的例子，如电源适配器等等，适配器模式又分为类适配器与对象适配器，分别如下： 类适配器被转换的类12345public class IntegerInput &#123; public int getIntegerInput() &#123; return new Random().nextInt(100); &#125;&#125; 目标接口123public interface StringOutput &#123; public String getString();&#125; 适配器类1234567public class AdapterIS extends IntegerInput implements StringOutput &#123; @Override public String getString() &#123; return &quot;String:&quot; + getIntegerInput(); &#125;&#125; 对象适配器对象适配器与类适配器有些许不同，使用了代理的思想，仅仅是适配器类与类适配器有所不同 123456789101112public class AdapterIS implements StringOutput &#123; IntegerInput integerInput; public AdapterIS(IntegerInput integerInput) &#123; this.integerInput = integerInput; &#125; @Override public String getString() &#123; return &quot;String:&quot; + integerInput.getIntegerInput(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从不同角度看同一数据结构-访问者模式]]></title>
    <url>%2F2018%2F01%2F24%2F%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[访问者模式是一种复杂的设计模式，使用频率不高，下面举一个公司对员工业绩考核的例子，CEO和CTO对员工的考核标准是不一样的 员工抽象类12345678910public abstract class Staff &#123; public String name; public int kpi; public Staff(String name) &#123; this.name = name; kpi = new Random().nextInt(10); &#125; public abstract void accept(Visitor visitor);&#125; 基类中只有员工的公共属性，这里是姓名和kpi 员工具体类 工程师类 1234567891011121314public class Engineer extends Staff &#123; public Engineer(String name) &#123; super(name); &#125; @Override public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; public int getCodeLines() &#123; return new Random().nextInt(10*10000); &#125;&#125; 产品经理类 1234567891011121314public class Manager extends Staff &#123; public Manager(String name) &#123; super(name); &#125; @Override public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; public int getProducts() &#123; return new Random().nextInt(10); &#125;&#125; 在具体类中加入独特的属性，这样访问者访问时就可以区别对待 抽象访问者类1234public interface Visitor &#123; void visit(Engineer engineer); void visit(Manager manager);&#125; 具体访问类 CEO：只关心员工的姓名和KPI 1234567891011public class CEO implements Visitor &#123; @Override public void visit(Engineer engineer) &#123; System.out.println(&quot;Engineer：&quot;+ engineer.name + &quot;, kpi: &quot; +engineer.kpi); &#125; @Override public void visit(Manager manager) &#123; System.out.println(&quot;Manager: &quot;+ manager.name + &quot;, kpi: &quot;+manager.kpi); &#125;&#125; CTO：根据岗位的不同关心不同的技术指标 1234567891011public class CTO implements Visitor &#123; @Override public void visit(Engineer engineer) &#123; System.out.println(&quot;Engineer: &quot; + engineer.name +&quot;, code: &quot; + engineer.getCodeLines()); &#125; @Override public void visit(Manager manager) &#123; System.out.println(&quot;Manager: &quot; + manager.name + &quot;, product: &quot;+ manager.getProducts()); &#125;&#125; 具体示例如下 123456789public class Main &#123; public static void main(String[] args) &#123; BusinessReport businessReport = new BusinessReport(); System.out.println(&quot;======CEO=====&quot;); businessReport.showReport(new CEO()); System.out.println(&quot;\n=====CTO=====&quot;); businessReport.showReport(new CTO()); &#125;&#125; 结果 访问者模式可以很方便地添加访问者，方便地从多种角度观察同一种数据结构]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[约瑟夫环问题]]></title>
    <url>%2F2018%2F01%2F23%2F%E7%BA%A6%E7%91%9F%E5%A4%AB%E5%9D%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[约瑟夫环问题可以分为普通和进阶两个，区别就是进阶问题需要考虑时间复杂度，而普通问题则没有这个需求 普通难度普通解法其实非常简单，具体思路如下： 如果链表为空或者链表节点数为1或者m小于1，则直接返回 在环型链表中遍历每个节点，不断转圈，不断让每个节点报数 当报数到达m时，就删除当前报数的节点 删除节点后，把链表连成环装，重复这个过程 直到剩下最后一个节点时，结束 算法如下：1234567891011121314151617181920public Node josephusKill(Node head, int m) &#123; if (head == null || head.next == head || m &lt; 1) &#123; return head; &#125; Node last = head; while (last.next != head) &#123; last = last.next; &#125; int count = 0; while (head != last) &#123; if (++count == m) &#123; last.next = head.next; count = 0; &#125; else &#123; last = last.next; &#125; head = last.next; &#125; return head; &#125; 这个算法没有实现时间复杂度为O（N）的要求 进阶进阶的算法中使用了递归的思想，具体思路如下： 与普通算法一样，先进行判断 遍历链表，求节点个数即为n 递归求生存节点的编号，由数学的思想直接找出对应的编号 根据生存节点的编号，遍历链表找到该节点 算法如下：123456789101112131415161718192021222324public Node josephusKill2(Node head, int m) &#123; if (head == null || head.next == head || m &lt; 1) &#123; return head; &#125; Node cur = head.next; int tmp = 1; while (cur != head) &#123; tmp ++; cur = cur.next; &#125; tmp = getLive(tmp, m); while (--tmp != 0) &#123; head = head.next; &#125; head.next = head; return head; &#125; public int getLive(int i, int m) &#123; if (i ==1) &#123; return 1; &#125; return (getLive(i-1, m) + m - 1) % i + 1; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式中的撤销-备忘录模式]]></title>
    <url>%2F2018%2F01%2F22%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%92%A4%E9%94%80-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在开发过程中，我们可能会遇到保存对象目前的状态，到必要的时候再进行恢复的需求，这类似于数据库中的后援副本，到出现故障时数据库可以回到转储时的状态 备忘录模式的示例在一般软件的开发中，备忘录模式是使用得比较少的设计模式，但是在游戏开发过程中，备忘录模式是使用得很频繁的，这里就举一个小游戏的例子 游戏类12345678910111213141516171819202122232425262728293031323334353637public class Mario &#123; private int checkPoint = 1; private int lifeValue = 100; private String state = &quot;正常&quot;; public void play() &#123; System.out.println(&quot;现在在：&quot; + String.format(&quot;第%d关&quot;, checkPoint)); lifeValue -= 10; System.out.println(&quot;过关！&quot;); checkPoint ++ ; System.out.println(&quot;现在是&quot; + String.format(&quot;第%d关&quot;,checkPoint)); &#125; public void quit() &#123; System.out.println(&quot;退出前的游戏属性：&quot; + this.toString()); &#125; public Memoto createMemoto () &#123; Memoto memoto = new Memoto(); memoto.checkPoint = checkPoint; memoto.state = state; memoto.lifeValue = lifeValue; return memoto; &#125; public void restore(Memoto memoto) &#123; this.checkPoint = memoto.checkPoint; this.lifeValue = memoto.lifeValue; this.state = memoto.state; System.out.println(&quot;恢复后的游戏属性：&quot; + this.toString()); &#125; @Override public String toString() &#123; return &quot;CheckPoint:&quot; + checkPoint + &quot;, LifeValue：&quot; + lifeValue +&quot;, State:&quot; + state; &#125;&#125; 备忘录类12345678910public class Memoto &#123; public int checkPoint; public int lifeValue; public String state; @Override public String toString() &#123; return &quot;CheckPoint:&quot; + checkPoint + &quot;, LifeValue：&quot; + lifeValue +&quot;, State:&quot; + state; &#125;&#125; 备忘录管理类1234567891011public class Caretaker &#123; Memoto memoto; public void archive(Memoto memoto) &#123; this.memoto = memoto; &#125; public Memoto getMemoto() &#123; return memoto; &#125;&#125; 使用示例1234567891011public class Main &#123; public static void main(String[] args) &#123; Mario mario = new Mario(); mario.play(); Caretaker caretaker = new Caretaker(); caretaker.archive(mario.createMemoto()); mario.quit(); Mario mario1 = new Mario(); mario1.restore(caretaker.getMemoto()); &#125;&#125; 结果如下： 当然，如果我们需要开发一个游戏，肯定是持久化存储与备忘录模式一起使用]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[特殊的继承关系-装饰模式]]></title>
    <url>%2F2018%2F01%2F20%2F%E7%89%B9%E6%AE%8A%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰模式使用一种对客户端透明的方案来动态地扩展对象的功能，同时它也是继承方案的一种替代方案之一。 这里举一个简答的汽车改装的例子来说明以下装饰模式的组成 基本抽象类123public abstract class Car &#123; public abstract void have();&#125; 具体类：继承基本抽象类123456public class Limousine extends Car &#123; @Override public void have() &#123; System.out.println(&quot;有基本的配置&quot;); &#125;&#125; 这是需要装饰的类，所以只需要最基本的东西 装饰抽象类1234567891011public abstract class CarRefit extends Car &#123; protected Car car; public CarRefit(Car car) &#123; this.car = car; &#125; @Override public void have() &#123; car.have(); &#125;&#125; 在装饰类中我们需要持有一个基本类的对象，以便进行装饰操作 具体装饰类1.1234567891011121314151617181920public class ExpensiveRefit extends CarRefit &#123; public ExpensiveRefit(Car car) &#123; super(car); &#125; @Override public void have() &#123; super.have(); haveHUD(); haveBetterEngine(); &#125; private void haveHUD() &#123; System.out.println(&quot;加装了HUD&quot;); &#125; private void haveBetterEngine() &#123; System.out.println(&quot;加装了更好的发动机&quot;); &#125;&#125; 2.1234567891011121314151617181920public class OtherRefit extends CarRefit &#123; public OtherRefit(Car car) &#123; super(car); &#125; @Override public void have() &#123; super.have(); havePaint(); haveEmpennage(); &#125; private void havePaint() &#123; System.out.println(&quot;加装了个性喷漆&quot;); &#125; private void haveEmpennage() &#123; System.out.println(&quot;加装了尾翼&quot;); &#125;&#125; 使用如下： 123456789public class Main &#123; public static void main(String[] args) &#123; Limousine limousine = new Limousine(); ExpensiveRefit expensiveRefit = new ExpensiveRefit(limousine); expensiveRefit.have(); OtherRefit otherRefit = new OtherRefit(limousine); otherRefit.have(); &#125;&#125; 结果 由上可知，装饰模式不需要依靠继承来实现功能的扩展，最重要的一步是抽象装饰类]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[同一编程接口-外观模式]]></title>
    <url>%2F2018%2F01%2F20%2F%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[外观模式接口比较简单，就是通过一个统一的接口对外提供服务，使得外部程序只通过一个类就可以实现系统内部的多种功能 这里就举一个由用户来操控手机的小例子 子系统接口类 手机通话系统接口 1234public interface Phone &#123; void dail(); void hangup();&#125; 相机系统接口 12345public interface Camera &#123; void open(); void tackPhoto(); void close();&#125; 子系统具体类 通话系统 1234567891011public class PhoneImpl implements Phone &#123; @Override public void dail() &#123; System.out.println(&quot;call&quot;); &#125; @Override public void hangup() &#123; System.out.println(&quot;hangup&quot;); &#125;&#125; 相机系统 12345678910111213141516public class PixelCamera implements Camera &#123; @Override public void open() &#123; System.out.println(&quot;open camera&quot;); &#125; @Override public void tackPhoto() &#123; System.out.println(&quot;tack photo&quot;); &#125; @Override public void close() &#123; System.out.println(&quot;close camera&quot;); &#125;&#125; 上层系统1234567891011121314151617public class MobilePhone &#123; private Phone phone = new PhoneImpl(); private Camera camera = new PixelCamera(); public void videoChat() &#123; camera.open(); phone.dail(); &#125; public void tackPhoto() &#123; camera.open(); camera.tackPhoto(); &#125; public void closeCamera() &#123; camera.close(); &#125;&#125; 使用如下 12345678public class Main &#123; public static void main(String[] args) &#123; MobilePhone pixel = new MobilePhone(); pixel.tackPhoto(); pixel.videoChat(); pixel.closeCamera(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解释器模式]]></title>
    <url>%2F2018%2F01%2F20%2F%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[解释器模式时一种使用的比较少的行为类设计模式，也比较难以理解，但是在系统设计的时候，解释器模式则被广泛地使用了，比如说在解析文件的时候 这里举一个解释器模式的简单例子 抽象算数运算解释器123public abstract class ArithmeticExpression &#123; public abstract int interpret();&#125; 数字解释器12345678910public class NumExpression extends ArithmeticExpression &#123; private int num; public NumExpression(int num) &#123; this.num = num; &#125; @Override public int interpret() &#123; return num; &#125;&#125; 符号解释器1234567public abstract class OperatorExpression extends ArithmeticExpression &#123; protected ArithmeticExpression exp1,exp2; public OperatorExpression(ArithmeticExpression exp1, ArithmeticExpression exp2) &#123; this.exp1 = exp1; this.exp2 = exp2; &#125;&#125; 加法运算解释器12345678910public class AdditionExpression extends OperatorExpression &#123; public AdditionExpression(ArithmeticExpression exp1, ArithmeticExpression exp2) &#123; super(exp1, exp2); &#125; @Override public int interpret() &#123; return exp1.interpret() + exp2.interpret(); &#125;&#125; 这里只是举了一个简单的加法算术例子，可能会显得有些鸡肋，但是在复杂的解析当中，解释器模式会起到很好的作用]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Builder模式的简单示例]]></title>
    <url>%2F2018%2F01%2F19%2FBuilder%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Builder模式可以说是最简单的设计模式了，它的原理就是封装set方法，每一步都由Builder对象来完成，使构建过程和部件的表示隔离开来，这里就仿造Android中的AlterDialog中的Builder模式 例如，用Builder模式来构造一个Person对象，对象如下：1234567891011121314151617public class Person &#123; private String name; private String sex; private int height; private void setName(String name) &#123; this.name = name; &#125; private void setSex(String sex) &#123; this.sex = sex; &#125; private void setHeight(int height) &#123; this.height = height; &#125;&#125; 注意，这里的set函数全都是private的，因为属性应该由Builder对象进行设置，而不是直接使用Person对象设置，完整的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Person &#123; private String name; private String sex; private int height; private void setName(String name) &#123; this.name = name; &#125; private void setSex(String sex) &#123; this.sex = sex; &#125; private void setHeight(int height) &#123; this.height = height; &#125; public static class Builder&#123; private Person person = null; public Builder() &#123; person = new Person(); &#125; public Builder setName(String name) &#123; person.name = name; return this; &#125; public Builder setSex(String sex) &#123; person.sex = sex; return this; &#125; public Builder setHeight(int height) &#123; person.height = height; return this; &#125; public Person create() &#123; return person; &#125; &#125;&#125; 这样就是一个简单Builder模式的实现了，因为Builder模式比较简单，大致都差不多]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对象内部的策略改变-状态模式]]></title>
    <url>%2F2018%2F01%2F18%2F%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E7%9A%84%E6%94%B9%E5%8F%98-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[状态模式比较常见的是运用在登陆或未登陆的情况下进行，因为在用户登陆与未登陆这两种情况下，对相同的动作会有不同的反应 状态模式的使用一般分为以下几步 定义状态接口以及相应的动作1234public interface State &#123; void statement(); void report();&#125; 定义每种不同的状态相应的动画 登陆状态时的动作 1234567891011public class LogOnState implements State &#123; @Override public void statement() &#123; System.out.println(&quot;statement fail&quot;); &#125; @Override public void report() &#123; System.out.println(&quot;report fail&quot;); &#125;&#125; 未登陆状态时的动作 1234567891011public class LogOutState implements State &#123; @Override public void statement() &#123; System.out.println(&quot;statement success&quot;); &#125; @Override public void report() &#123; System.out.println(&quot;report success&quot;); &#125;&#125; 定义状态所对应的实体类，比如说这里的User类12345678910111213141516171819202122232425public class User &#123; private State state = new LogOutState(); public User() &#123; &#125; private void setState(State state) &#123; this.state = state; &#125; public void LogOn() &#123; setState(new LogOnState()); &#125; public void LogOut() &#123; setState(new LogOutState()); &#125; public void statement() &#123; state.statement(); &#125; public void report() &#123; state.report(); &#125;&#125; 这里定义了一个默认的状态就是未登陆的，这和实际中的场景相似 实现代码如下：12345678910public class Main &#123; public static void main(String[] args) &#123; User user = new User(); user.statement(); user.report(); user.LogOn(); user.statement(); user.report(); &#125;&#125; 当然，这里只是最简单的示例，在实际开发过程中状态模式的作用这里还没有体现出来，总结来说就是，策略模式时去掉了在“外部的”if-else，而状态模式则是去掉了内部的”“if-else，两种设计模式的不同就是：在策略模式下，策略是由用户选择的，而在状态模式下，策略则是由类内部自动改变，不需要用户的干预，适合于像处理用户的登陆状态与未登陆状态这样的情况。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中内置的设计模式-观察者模式]]></title>
    <url>%2F2018%2F01%2F17%2FJava%E4%B8%AD%E5%86%85%E7%BD%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式是jdk中内置的模式，也是使用频率最为广泛的设计模式之一，著名的开源项目如RxJava、EventBus中都能够看到它的影子，甚至在跨进程通信中，我们也经常用到观察者模式 这里只举例一个使用jdk中内置观察者模式的例子：公众号发推送的例子，公众号发文章后，每个订阅该公众号的用户都会得到推送 观察者12345678910public class User implements Observer &#123; private String Name; public User(String Name) &#123; this.Name = Name; &#125; @Override public void update(Observable o, Object arg) &#123; System.out.println( Name + &quot; 收到新推送：&quot; + arg); &#125;&#125; 注意，update函数中的arg即为被观察者发送出的消息，在这个例子中就是公众号发出来的消息 被观察者：推送消息123456public class GongZhongHao extends Observable &#123; public void push(String content) &#123; setChanged(); notifyObservers(content); &#125;&#125; setChanged和notifyObservers两个函数要一起使用 具体使用123456789101112public class Main &#123; public static void main(String[] args) &#123; User user1 = new User(&quot;User1&quot;); User user2 = new User(&quot;User2&quot;); User user3 = new User(&quot;User3&quot;); GongZhongHao gongZhongHao = new GongZhongHao(); gongZhongHao.addObserver(user1); gongZhongHao.addObserver(user2); gongZhongHao.addObserver(user3); gongZhongHao.push(&quot;比特币大跌&quot;); &#125;&#125; 结果如下：]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2018%2F01%2F17%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[命令模式对简单的调用关系进行解耦，再大多数情况下我们可以使用直接调用的方式来做，但是如果调用比较繁琐，那么使用命令模式不失为一个好选择 这里举一个超级马里奥移动的例子来讲解命令模式 超级马里奥的动作类12345678910111213public class Mario &#123; public void toLeft() &#123; System.out.println(&quot;向左移&quot;); &#125; public void toRight() &#123; System.out.println(&quot;向右移&quot;); &#125; public void toJump() &#123; System.out.println(&quot;跳跃&quot;); &#125;&#125; 定义执行方法接口123public interface Command &#123; void execute();&#125; 定义具体命令类 跳命令 12345678910public class JumpCommand implements Command &#123; private Mario mario; public JumpCommand(Mario mario) &#123; this.mario = mario; &#125; @Override public void execute() &#123; mario.toJump(); &#125;&#125; 左移命令 12345678910public class LeftCommand implements Command &#123; private Mario mario; public LeftCommand(Mario mario) &#123; this.mario = mario; &#125; @Override public void execute() &#123; mario.toLeft(); &#125;&#125; 右移命令 12345678910public class RightCommand implements Command &#123; private Mario mario; public RightCommand(Mario mario) &#123; this.mario = mario; &#125; @Override public void execute() &#123; mario.toRight(); &#125;&#125; 命令的包装：按钮类1234567891011121314151617181920212223242526272829public class Button &#123; private JumpCommand jumpCommand; private LeftCommand leftCommand; private RightCommand rightCommand; public void setJumpCommand(JumpCommand jumpCommand) &#123; this.jumpCommand = jumpCommand; &#125; public void setLeftCommand(LeftCommand leftCommand) &#123; this.leftCommand = leftCommand; &#125; public void setRightCommand(RightCommand rightCommand) &#123; this.rightCommand = rightCommand; &#125; public void jump() &#123; jumpCommand.execute(); &#125; public void left() &#123; leftCommand.execute(); &#125; public void right() &#123; rightCommand.execute(); &#125;&#125; 具体执行123456789101112131415public class Main &#123; public static void main(String[] args) &#123; Mario mario = new Mario(); LeftCommand leftCommand = new LeftCommand(mario); RightCommand rightCommand = new RightCommand(mario); JumpCommand jumpCommand = new JumpCommand(mario); Button button = new Button(); button.setJumpCommand(jumpCommand); button.setLeftCommand(leftCommand); button.setRightCommand(rightCommand); button.jump(); button.left(); button.right(); &#125;&#125; 命令类可以在相当程度上实现调用逻辑的解耦，但是像大家看到的一样，需要多出很多的类，但是这样设计模式的原则：对修改关闭，对扩展开放，才能提到体现]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[容器中的游标-迭代器模式]]></title>
    <url>%2F2018%2F01%2F17%2F%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E6%B8%B8%E6%A0%87-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[迭代器模式又称为游标模式，Java中的List遍历就可以使用迭代器，而不需要使用“明显”的遍历算法，下面举一个迭代器模式的小例子 迭代器接口1234public interface Iterator&lt;T&gt; &#123; boolean hasNext(); T next();&#125; 具体迭代器类12345678910111213141516171819202122public class ConcreteIterator&lt;T&gt; implements Iterator &#123; private List&lt;T&gt; list = new ArrayList&lt;T&gt;(); private int cursor = 0; public ConcreteIterator(List&lt;T&gt; list) &#123; this.list = list; &#125; @Override public boolean hasNext() &#123; return cursor != list.size(); &#125; @Override public Object next() &#123; T obj = null; if (this.hasNext()) &#123; obj = this.list.get(cursor++); &#125; return obj; &#125;&#125; 容器接口12345public interface Aggregate&lt;T&gt; &#123; void add(T obj); void remove(T obj); Iterator&lt;T&gt; iterator();&#125; 具体容器类1234567891011121314151617public class ConcreteAggregate&lt;T&gt; implements Aggregate&lt;T&gt; &#123; private List&lt;T&gt; list = new ArrayList&lt;T&gt;(); @Override public void add(T obj) &#123; list.add(obj); &#125; @Override public void remove(T obj) &#123; list.remove(obj); &#125; @Override public Iterator&lt;T&gt; iterator() &#123; return new ConcreteIterator&lt;T&gt;(list); &#125;&#125; 实现示例123456789101112public class Main &#123; public static void main(String[] args) &#123; Aggregate&lt;String&gt; aggregate = new ConcreteAggregate&lt;&gt;(); aggregate.add(&quot;android&quot;); aggregate.add(&quot;studio&quot;); aggregate.add(&quot;Google&quot;); Iterator&lt;String&gt; iterator = aggregate.iterator(); while (iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125;&#125; 实际上，迭代器模式是一个不需要由开发者实现的模式，这里只是来解析以下迭代器是怎样构成的，实际上List容器有自带的迭代器，不需要我们自己实现]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单链表的选择排序]]></title>
    <url>%2F2018%2F01%2F16%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序我们一般在数组中会使用选择排序对数组中的数字进行处理，而在单链表当中，问题就比较有难度了，解题思路如下： 开始时默认整个链表未排序，找到最小节点记为newHead 每次都在未排序的部分当中找到最小值的节点，把这个节点在未排序的链表中删除 把步骤2中删除的节点加入到已排序的链表中 全部处理完毕后返回newHead 具体算法如下：1234567891011121314151617181920212223242526272829303132333435363738public Node selectSort(Node head) &#123; Node tail = null; Node cur = head; Node smallPre = null; Node small = null; while (cur != null) &#123; small = cur; smallPre = getSmallestPreNode(cur); if (smallPre != null) &#123; small = smallPre.next; smallPre.next = small.next; &#125; cur = cur==small?cur.next:cur; if(tail == null) &#123; head = small; &#125; else &#123; tail.next = small; &#125; tail = small; &#125; return head; &#125; public Node getSmallestPreNode(Node head) &#123; Node smallPre = null; Node small = head; Node pre = head; Node cur = head.next; while (cur != null) &#123; if (cur.value &lt; small.value) &#123; smallPre = pre; small = cur; &#125; pre = cur; cur = cur.next; &#125; return smallPre; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Gradle Task]]></title>
    <url>%2F2018%2F01%2F16%2Fgradle%20task%2F</url>
    <content type="text"><![CDATA[task 的创建方式快捷方式我们一般使用最快捷的方式来创建任务，像这样 123task hello &lt;&lt; &#123; println &apos;Hello world!&apos;&#125; 动态方式我们可以使用groovy动态地创建任务，像这样 123453.times &#123; counter -&gt; task &quot;task$counter&quot; &lt;&lt; &#123; println &quot;this is task$counter&quot; &#125;&#125; 这里会生成task1、task2、task3这三个任务，我们可以运行其中的任何一个 这里之所以不介绍其他的方式，是因为gradle的版本迭代十分迅速，一些方法已经不适用了，所以这里只介绍这一种 task的行为周期gradle中的task有First、本身（这里暂时这么称呼）、Last以及后添加的行为，这里举个例子123456789101112131415task hello &lt;&lt; &#123; println &quot;this is main&quot;&#125;hello.doFirst&#123; println &quot;this is first&quot;&#125;hello.doLast&#123; println &quot;this is Last&quot;&#125;hello&lt;&lt; &#123; println &quot;this is add&quot;&#125; 运行后结果如下： 从中我们可以得出，task行为的执行次序是：doFirst，task本身，doLast，后来添加的任务 task间的依赖比较奇特的是，task之间也可以存在依赖，如下 1234567task one&lt;&lt; &#123; println &apos;one&apos;&#125;task two(dependsOn:one) &lt;&lt;&#123; println &apos;two&apos;&#125; task间存在的依赖很像类的构造函数，比如这里two依赖于one，如果我们看成two继承于one的话，就很容易理解了，这样two创建之间必须先实行one的构造函数，这里就是先执行one函数 task动态任务与task依赖结合使用除了上述的一种定义方法之外，我们也可以使用另一种方法来定义依赖1task1.dependsOn task2 这样执行task1之前就会先执行task2了，我们也可以使用动态生成的方式来看一下 12345673.times &#123; counter -&gt; task &quot;task$counter&quot; &lt;&lt; &#123; println &quot;this is task$counter&quot; &#125;&#125;task1.dependsOn task0, task2 运行结果如下 默认任务 在使用gradle中我们要执行一个任务，通常是这样1grale 任务名 但其实我们可以指定一个或多个任务作为默认任务，这样直接用gradle即可，例如12345defaultTasks &apos;hello&apos;task hello &lt;&lt; &#123; println &quot;this is main&quot;&#125; 结果如下]]></content>
      <categories>
        <category>gradle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[让函数有执行顺序-模板方法模式]]></title>
    <url>%2F2018%2F01%2F15%2F%E8%AE%A9%E5%87%BD%E6%95%B0%E6%9C%89%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[我们知道在一般情况下，Android中Activity的生命周期如图所示 执行顺序为onCreate()-&gt;onStart()-&gt;onResume()-&gt;onPause()-&gt;onStop()-&gt;onDestroy()，这个就是模板方法模式的使用之一 我们可以来模拟以下Activity所使用的模板方法模式，具体步骤如下： 抽象类：定义算法框架，也就是执行顺序12345678910111213141516171819202122232425262728293031323334public abstract class AbstractActivity &#123; protected void onCreate() &#123; System.out.println(&quot;onCreate()&quot;); &#125; protected void onStart() &#123; System.out.println(&quot;onStart()&quot;); &#125; protected void onResume() &#123; System.out.println(&quot;onResume()&quot;); &#125; protected void onPause() &#123; System.out.println(&quot;onPause()&quot;); &#125; protected void onStop() &#123; System.out.println(&quot;onStop&quot;); &#125; protected void onDestroy() &#123; System.out.println(&quot;onDestroy&quot;); &#125; public final void work() &#123; onCreate(); onStart(); onResume(); onPause(); onStop(); onDestroy(); &#125;&#125; 实现类 MainActivity 1234567public class MainActivity extends AbstractActivity &#123; @Override protected void onCreate() &#123; super.onCreate(); System.out.println(&quot;This is MainActivity&quot;); &#125;&#125; SecondActivity 1234567public class SecondActivity extends AbstractActivity &#123; @Override protected void onCreate() &#123; super.onCreate(); System.out.println(&quot;This is SecondActivity&quot;); &#125;&#125; 使用如下： 12345678public class Main &#123; public static void main(String[] args) &#123; MainActivity mainActivity = new MainActivity(); mainActivity.work(); SecondActivity secondActivity = new SecondActivity(); secondActivity.work(); &#125;&#125; 运行结果 这里只是简单地举了个模板方法模式的小例子，我们还可以在不同的实现类加上函数，如登陆函数等等，这样一个模板方法就可以被大范围地使用]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中介者模式]]></title>
    <url>%2F2018%2F01%2F15%2F%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[中介者模式主要是解决两个对象间相互作用时产生的耦合 这里举一个简单的电脑组装的例子，电脑中的组件，如CPU、显卡、内存等等都是通过主板进行工作，主板就扮演着一个中介者的角色 抽象中介者类123public abstract class Mediator &#123; public abstract void changed(Colleague colleague);&#125; 抽象组件类123456public abstract class Colleague &#123; protected Mediator mediator; public Colleague(Mediator mediator) &#123; this.mediator = mediator; &#125;&#125; 具体组件类1234567891011121314151617public class CDDevice extends Colleague &#123; private String data; public CDDevice(Mediator mediator) &#123; super(mediator); &#125; public String read() &#123; return data; &#125; public void load() &#123; data = &quot;VideoData,SoundData&quot;; mediator.changed(this); &#125;&#125; 123456789101112131415161718192021public class CPU extends Colleague &#123; private String dataVideo,dataSound; public CPU(Mediator mediator) &#123; super(mediator); &#125; public String getDataSound() &#123; return dataSound; &#125; public String getDataVideo() &#123; return dataVideo; &#125; public void decodeData(String data) &#123; String[] tmp = data.split(&quot;,&quot;); dataVideo = tmp[0]; dataSound = tmp[1]; mediator.changed(this); &#125;&#125; 123456789public class GraphicsCard extends Colleague &#123; public GraphicsCard(Mediator mediator) &#123; super(mediator); &#125; public void videoPlay(String data) &#123; System.out.println(&quot;Video: &quot;+ data); &#125;&#125; 123456789public class SoundCard extends Colleague &#123; public SoundCard(Mediator mediator) &#123; super(mediator); &#125; public void soundPlay(String data)&#123; System.out.println(&quot;Sound: &quot;+data); &#125;&#125; 具体中介者123456789101112131415161718192021222324252627282930313233343536373839public class MainBoard extends Mediator &#123; private CDDevice cdDevice; private CPU cpu; private SoundCard soundCard; private GraphicsCard graphicsCard; @Override public void changed(Colleague colleague) &#123; if (colleague == cdDevice) &#123; handleCD((CDDevice) colleague); &#125; else if (colleague == cpu) &#123; handleCPU((CPU)colleague); &#125; &#125; private void handleCD(CDDevice cdDevice) &#123; cpu.decodeData(cdDevice.read()); &#125; private void handleCPU(CPU cpu) &#123; soundCard.soundPlay(cpu.getDataSound()); graphicsCard.videoPlay(cpu.getDataVideo()); &#125; public void setCdDevice(CDDevice cdDevice) &#123; this.cdDevice = cdDevice; &#125; public void setCpu(CPU cpu) &#123; this.cpu = cpu; &#125; public void setSoundCard(SoundCard soundCard) &#123; this.soundCard = soundCard; &#125; public void setGraphicsCard(GraphicsCard graphicsCard) &#123; this.graphicsCard = graphicsCard; &#125;&#125; 示例1234567891011121314public class Main &#123; public static void main(String[] args) &#123; MainBoard mainBoard = new MainBoard(); CDDevice cdDevice = new CDDevice(mainBoard); CPU cpu = new CPU(mainBoard); GraphicsCard graphicsCard = new GraphicsCard(mainBoard); SoundCard soundCard = new SoundCard(mainBoard); mainBoard.setCdDevice(cdDevice); mainBoard.setCpu(cpu); mainBoard.setGraphicsCard(graphicsCard); mainBoard.setSoundCard(soundCard); cdDevice.load(); &#125;&#125; 中介者类负责各个组件之间的配合,所以各个组件之间的耦合度会降低，最后只需要启动一个组件的动作，通信工作就由中介者负责]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gradle Wapper及其他]]></title>
    <url>%2F2018%2F01%2F15%2FGradle%20Wrapper%E5%8F%8A%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[Wrapper是对gradle的一层包装，是为了在开发过程中可以使用同样的gradle版本进行开发r 生成wrapper想要为自己的项目引入gradle，我们只需要在Terminal下输入 1gradle wrapper 接着就构建成功了 可以看到，根目录下多了如下文件 我们可以指定一些参数来控制gradle的生成，如依赖的版本等等，方法如下：12-gradle-version //指定版本-gradle-distribution-url //指定url地址用于下载gradle发行版 查看gradle-wrapper.properties，如下所示 除了使用gradle命令行生成wrapper以外，还可以通过自定义task的方式来生成wrapper123task wrapper(type:Wrapper) &#123; gradleVersion = &apos;4.4&apos;&#125; 这时候再运行命令行gradle wrapper,在gradle-wrapper.properties中看到的时这样的 当然我们也可以在自定义task中指定其他参数。 和其他命令行的使用方式一样，gradle wrapper也提供了帮助的选项，我们可以使用123gradle wrapper -?gradle wrapper -hgradle wrapper --help 会得到如下输出 注意！在Windows下我们必须使用gradle wrapper这个完整的命令，而在linux下可以使用./gradlew这个简写，很多书中并没有提到，这里特别提一下 除此之外，我们还可以使用gradle wrapper tasks来查看可以执行的task 还有强制刷新依赖 1gradle wrapper --refresh -dependencies assemble 对class文件进行清理 1gradle wrapper clean jar 注意，如果单词比较长，我们也可以使用驼峰命名法的缩写来进行调用]]></content>
      <categories>
        <category>gradle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[复杂对象的创建-工厂方法模式]]></title>
    <url>%2F2018%2F01%2F13%2F%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在Android开发中，最常见的工厂模式应该就是Bitmap的创建了，因为Bitmap的创建是分很多种方式的，我们可以使用本地文件来创建Bitmap对象，也可以使用网络上的资源来创建Bitmap对象，具体方法如下： 123BitmapFactory.decodeResource(this.getResources(),R.drawable.haha); //使用本地文件HttpURLConnection con = (HttpURLConnection) conurl.openConnection();BitmapFactory.decodeStream(con.getInputStream()); //使用网络资源 下面来模拟一下Bitmap对象的创建过程 创建抽象产品类 12345public abstract class BitmapProduct &#123; //定义属性及方法 public void method()&#123; &#125;&#125; 创建具体产品类 123456public class srcBiamapProduct extends BitmapProduct &#123; @Override public void method() &#123; System.out.print(&quot;srcBitmap&quot;); &#125;&#125; 本地文件生成的Bitmap对象123456public class networkBitmapProduct extends BitmapProduct &#123; @Override public void method() &#123; System.out.print(&quot;networkBitmapProduct&quot;); &#125;&#125; 网络资源生成的Bitmap对象 创建抽象工厂类 123public abstract class BitmapFactory &#123; public abstract BitmapProduct createBitmap();&#125; 创建具体工厂类 123456public class concreteFactory extends BitmapFactory &#123; @Override public BitmapProduct createBitmap() &#123; return new srcBiamapProduct(); &#125;&#125; 使用如下：123456public class Main &#123; public static void main(String[] args) &#123; BitmapFactory bitmapFactory = new concreteFactory(); bitmapFactory.createBitmap(); &#125;&#125; 这里的Bitmap创建和我们在Android开发时所使用的工厂模式还是有区别的，因为在Android中Bitmap创建采用的时静态工厂模式，像这样12345public class BitmapFactory &#123; public static srcBiamapProduct createBitmap() &#123; return new srcBiamapProduct(); &#125;&#125; 除了上述的一般方法之外，我们也可以使用反射来进行创建，不过鉴于反射会对性能产生影响，要慎用 抽象工厂类 123public abstract class BitmapFactory &#123; public abstract &lt;T extends BitmapProduct&gt; T createBitmap(Class&lt;T&gt; tClass);&#125; 具体工厂类123456789101112public class concreteFactory extends BitmapFactory &#123; @Override public &lt;T extends BitmapProduct&gt; T createBitmap(Class&lt;T&gt; tClass) &#123; BitmapProduct bitmapProduct = null; try &#123; bitmapProduct = (BitmapProduct) Class.forName(tClass.getName()).newInstance(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; return (T) bitmapProduct; &#125;&#125; 使用123456public class Main &#123; public static void main(String[] args) &#123; BitmapFactory bitmapFactory = new concreteFactory(); bitmapFactory.createBitmap(srcBiamapProduct.class); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gradle中使用的编程语言-Groovy]]></title>
    <url>%2F2018%2F01%2F13%2Fgradle%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Groovy%2F</url>
    <content type="text"><![CDATA[和Java一样，Groovy也是基于JVM虚拟机的一种动态语言，甚至Groovy完全兼容Java，当然，它也有很多Java没有的特性，比如支持闭包和DSL 关于Groovy字符串、集合、方法的使用这里就不说了，即使是从来都没有接触过Groovy，我们见到的时候也能明白，网上也有大量的资料，这里就不赘述了 闭包 闭包是Groovy的一个非常重要的特性，也是DSL的基础 首先，举一个简单的闭包例子 自定义task如下： 123456789101112task helloClosure &lt;&lt; &#123; //使用自定义闭包 customEach &#123; println it &#125;&#125;def customEach(closure) &#123; for (int i in 1..10)&#123; closure(i) &#125;&#125; 执行gradle helloClosure，我们得到 很容易看出，closure（i）中的i就是我们在helloClosure中的it了 我们也可以使用map向闭包传递参数12345678910111213task helloClosure &lt;&lt; &#123; eachMap&#123; k,v -&gt; println &quot;$&#123;k&#125; is $&#123;v&#125;&quot; &#125;&#125;def eachMap(closure) &#123; def map =[&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:18] map.each &#123; closure(it.key,it.value) &#125;&#125; 结果是这样的 闭包委托 在软件开发中我们经常用到委托模式，而在Groovy中直接提供了闭包委托，把具体的实现方法放到task中实现 123456789101112131415161718192021222324task configPerson &lt;&lt; &#123; person&#123; personName = &quot;张三&quot; personAge = 20 dumpPerson() &#125;&#125;class Person&#123; String personName int personAge def dumpPerson() &#123; println &quot;name is $&#123;personName&#125;, age is $&#123;personAge&#125;&quot; &#125;&#125;def person(closure) &#123; Person p = new Person() closure.delegate = p closure(p)&#125; DSLDSL指的是领域特定语言，在这里就是指的Gradle，是基于Groovy的，Gradle脚本就是按照Gradle DSL定义的]]></content>
      <categories>
        <category>gradle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[判断一个链表是否为回文结构]]></title>
    <url>%2F2018%2F01%2F13%2F%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[回文结构，即链表为5-&gt;2-&gt;3-&gt;2-&gt;5这样的结构，本道题的两种解法一种为简单解法，另一种为进阶解法（多了时间复杂度的要求） 普通解法利用栈的先进后出特点，遍历的过程中把每个节点依次压入栈中，遍历完成后，从栈顶到栈底的值出现顺序会与原链表从头到尾的值反过来，可以根据这个来判断是否为回文结构 具体算法如下 123456789101112131415public boolean isPalindromel(Node head) &#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node cur = head; while (cur != null) &#123; stack.push(cur); cur = cur.next; &#125; while (head != null) &#123; if (head.value != stack.pop().value) &#123; return false; &#125; head = head.next; &#125; return true; &#125; 进阶解法进阶解法与普通解法的不同就是进阶解法只需要将链表中一半的节点压入，只需要让栈压出的节点与链表右半区的节点依次比较，即可得出链表是否为回文结构 具体算法如下 1234567891011121314151617181920212223public boolean isPalindrome2(Node head) &#123; if (head == null || head.next == null) &#123; return true; &#125; Node right = head.next; Node cur = head; while (cur.next != null &amp;&amp; cur.next.next != null) &#123; right = right.next; cur = cur.next.next; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); while (right != null) &#123; stack.push(right); right = right.next; &#125; while (!stack.isEmpty()) &#123; if (head.value != stack.pop().value) &#123; return false; &#125; head = head.next; &#125; return true; &#125; 其他思路 上面两种解法都使用了栈，也有一种不使用栈的解法，不过稍微复杂，具体思路如下： 反转右半区的结构，使整个链表反转，最后指向中间节点 使左半区的头节点leftstart和右半区的节点rightstart节点同时向中间节点移动，移动每一步都比较leftstart和rigerstart的值，若完全相等则使回文结构，否则不是 返回结果前恢复链表的结构 返回结果 具体代码如下 12345678910111213141516171819202122232425262728293031323334353637383940public boolean isPalindrome3(Node head) &#123; if (head == null || head.next == null) &#123; return true; &#125; Node n1 = head; Node n2 = head; while (n2.next != null &amp;&amp; n2.next.next != null) &#123; n1 = n1.next; n2 = n2.next.next; &#125; n2 = n1.next; n1.next = null; Node next = null; while (n2 != null) &#123; //反转右半区 next = n2.next; n2.next = n1; n1 = n2; n2 = next; &#125; next = n1; n2 = head; boolean res = true; while (n1 != null &amp;&amp; n2 != null) &#123; if (n1.value != n2.value) &#123; res = false; break; &#125; n1 = n1.next; n2 = n2.next; &#125; n1 = next.next; next.next = null; while (n1 != null) &#123; n2 = n1.next; n1.next = next; next = n1; n1 = n2; &#125; return res; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[创建同一”类别“下的对象-抽象工厂模式]]></title>
    <url>%2F2018%2F01%2F12%2F%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[抽象工厂模式看起来与工厂方法模式相似，但工厂方法模式构建的是继承同一抽象类的对象，而抽象工厂模式创建出的对象并不是继承于同一基类的，所以，我们无法使用工厂方法模式那样的反射来创建对象 抽象工厂模式的类主要分为四类，分别是：抽象工厂类、具体工厂类、抽象产品类、具体产品类。 与工厂方法模式不同的地方是工厂方法模式的抽象产品类和具体工厂类只有一个，而抽象工厂模式的抽象产品类可能有许多个，具体工厂类也可能有许多个，其相当于每个产品都有不同的组件据称 抽象产品类123public abstract class AbstractPartA &#123; public abstract void statement();&#125; 123public abstract class AbstractPartB &#123; public abstract void statement();&#125; 具体产品类123456public class PartA1 extends AbstractPartA &#123; @Override public void statement() &#123; System.out.println(&quot;PartA1&quot;); &#125;&#125; 123456public class PartA2 extends AbstractPartA &#123; @Override public void statement() &#123; System.out.println(&quot;PartA2&quot;); &#125;&#125; 123456public class PartB1 extends AbstractPartB &#123; @Override public void statement() &#123; System.out.println(&quot;PartB1&quot;); &#125;&#125; 123456public class PartB2 extends AbstractPartB &#123; @Override public void statement() &#123; System.out.println(&quot;PartB2&quot;); &#125;&#125; 这里的具体产品类类似于一个产品的部件有很多的等级，A与B是两个不同的部件，而A1和A2则代表了两个不同的等级，可以假设这里的A1要比A2好一点，贵一些 抽象工厂类 1234public abstract class AbstractFactory &#123; public abstract AbstractPartA createPartA(); public abstract AbstractPartB createPartB();&#125; 具体工厂类 具体工厂类类似于上面各种具体产品的组合 1234567891011public class ProductFactoryOne extends AbstractFactory &#123; @Override public AbstractPartA createPartA() &#123; return new PartA1(); &#125; @Override public AbstractPartB createPartB() &#123; return new PartB2(); &#125;&#125; 1234567891011public class ProductFactoryTwo extends AbstractFactory &#123; @Override public AbstractPartA createPartA() &#123; return new PartA2(); &#125; @Override public AbstractPartB createPartB() &#123; return new PartB2(); &#125;&#125; 当然，这里的组合方式不知这两种，应该有四种，这里就不一一列举出来了]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gradle的执行顺序]]></title>
    <url>%2F2018%2F01%2F12%2Fgradle%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[gradle执行顺序是理解gradle的重要一步，我们可以随便举一个多项目的例子 例如 其中Project为FancyView，由两个Module，app和OpingStartAnimation组成，还有配置文件seetings.gradle 执行顺序为： 解析settings.gardle 配置模块 执行project的afterEvaluate回调 执行task]]></content>
      <categories>
        <category>gradle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[反转单向和双向链表]]></title>
    <url>%2F2018%2F01%2F11%2F%E5%8F%8D%E8%BD%AC%E5%8D%95%E5%90%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[反转单向链表 解题思路如下 首先声明两个指针pre和next，初始值为null 当头节点不为空时，next指针指向头节点的下一个节点，头节点的下一个节点指向pre（若为第一次循环则为空），pre指向当前头结点，头节点则指向next，此为一个循环 循环结束后返回pre指针，即当前的头指针具体代码如下 1234567891011public Node reverseList(Node head) &#123; Node pre = null; Node next = null; while (head != null) &#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre; &#125; 反转双向链表 解题思路如下 声明两个指针pre和next，初始值为null 当head指针指向的节点不为空时，next指针指向head的下一个指针，head的下一个指针指向pre节点（第一次循环时为空），head的上一个节点指向next指针，pre指针则指向head节点，head指针再指向next 循环结束后返回pre指针，即为当前的头节点 具体代码如下123456789101112public DoubleNode reverseList(DoubleNode head) &#123; DoubleNode pre = null; DoubleNode next = null; while (head != null) &#123; next = head.next; head.next = pre; head.last = next; pre = head; head = next; &#125; return pre; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在单链表和双链表中删除倒数第K个节点]]></title>
    <url>%2F2018%2F01%2F10%2F%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%92%8C%E5%8F%8C%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[思路 设要删除的为倒数第K个节点，第一遍遍历从头指针开始，每到下一个节点K就减1，若指针走到尽头K大于等于1，则链表长度不满足要求，若等于0则要删除的是头节点 若K小于0，则开始第二次遍历，每到下一节点K就加1，K为0时所到的节点后一节点即为要删除的节点 单链表算法123456789101112131415161718192021public Node removeLastKthNode(Node head, int lastKth) &#123; if (head == null || lastKth &lt; 1)&#123; return head; &#125; Node cur = head; while (cur != null) &#123; lastKth --; cur = cur.next; &#125; if (lastKth == 0) &#123; head = head.next; &#125; if (lastKth &lt; 0) &#123; cur = head; while (++lastKth != 0) &#123; cur = cur.next; &#125; cur.next = cur.next.next; &#125; return head; &#125; 双链表算法12345678910111213141516171819202122232425public DoubleNode removeLastKthNode(DoubleNode head, int lastKth) &#123; if (head == null || lastKth &lt; 1)&#123; return head; &#125; DoubleNode cur = head; while (cur != null) &#123; lastKth --; cur = cur.next; &#125; if (lastKth == 0) &#123; head = head.next; &#125; if (lastKth &lt; 0) &#123; cur = head; while (++lastKth != 0) &#123; cur = cur.next; &#125; DoubleNode newNext = cur.next.next; cur.next = newNext; if (newNext != null) &#123; newNext.last = cur; &#125; &#125; return head; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[原型模式与保护性拷贝]]></title>
    <url>%2F2018%2F01%2F09%2F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[原型模式可以理解为直接从已存在的对象中拷贝出一个新对象，在重新创建一个对象消耗较大，但又需要用到两个相互不影响的对象的时候才用到，这是它与单例模式的区别所在 原型模式中拷贝的方法有浅拷贝和深拷贝两种，浅拷贝因为直接引用对象，所以在修改拷贝出的对象的时候可能会影响到原对象，下面用购物商城的用户举个简单的例子12345678910111213141516171819202122232425262728293031public class User&#123; public User()&#123; &#125; private String name; private Image icon; private ArrayList&lt;String&gt; address = new ArrayList&lt;&gt;(); public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Image getIcon() &#123; return icon; &#125; public void setIcon(Image icon) &#123; this.icon = icon; &#125; public ArrayList&lt;String&gt; getAddress() &#123; return address; &#125; public void setAddress(ArrayList&lt;String&gt; address) &#123; this.address = address; &#125;&#125; 浅拷贝 用户有用户名、头像、多个地址，如果要进行拷贝的话应该继承Cloneable接口并重写clone()函数，下面是浅拷贝的例子12345678910111213@Override protected User clone() &#123; try &#123; User user = (User)super.clone(); user.icon = this.icon; user.name = this.name; user.address = this.address; return user; &#125; catch (CloneNotSupportedException e)&#123; &#125; return null; &#125; 为什么称它为浅拷贝呢？因为在User类中我们使用的是引用型字段，即ArrayList，如果我们对拷贝对象的ArrayList中的对象进行修改，原对象也会受到影响，和拷贝对象中的地址保持一致，所以我们应该使用深拷贝，对引用型字段也进行拷贝，而不是简单地赋值 深拷贝12345678910111213@Override protected User clone() &#123; try &#123; User user = (User)super.clone(); user.icon = this.icon; user.name = this.name; user.address = (ArrayList&lt;String&gt;) this.address.clone(); //对引用型字段进行拷贝 return user; &#125; catch (CloneNotSupportedException e)&#123; &#125; return null; &#125; 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class User implements Cloneable&#123; public User()&#123; &#125; private String name; private Image icon; private ArrayList&lt;String&gt; address = new ArrayList&lt;&gt;(); @Override protected User clone() &#123; try &#123; User user = (User)super.clone(); user.icon = this.icon; user.name = this.name; user.address = (ArrayList&lt;String&gt;) this.address.clone(); return user; &#125; catch (CloneNotSupportedException e)&#123; &#125; return null; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Image getIcon() &#123; return icon; &#125; public void setIcon(Image icon) &#123; this.icon = icon; &#125; public ArrayList&lt;String&gt; getAddress() &#123; return address; &#125; public void setAddress(ArrayList&lt;String&gt; address) &#123; this.address = address; &#125;&#125; 保护性拷贝 保护性拷贝其实就是原型模式的一个实际应用，比如说上面举的商城的例子，如果我们在其他需要用到User对象的场景下不小心修改了User对象，那将使服务端和客户端的信息不一致，所以在这个场景下十分适合使用原型模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gradle中的Setting文件与Build文件]]></title>
    <url>%2F2018%2F01%2F08%2Fgradle%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Setting文件Setting文件可以说是子项目（也可以说是Module）的配置文件，大多数setting.gradle的作用是为了配置子工程，再Gradle多工程是通过工程树表示的，如在Android studio中我们指定相应的module能在主工程当中使用，需要这样 1include &apos;:example&apos; Build文件Build是Project的配置文件，我们可以配置版本，插件，依赖库等等的信息，比较常见的就是Jcenter仓库的配置1234567891011121314buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.0.1&apos; classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.4.1&apos; classpath &apos;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.2&apos; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;]]></content>
      <categories>
        <category>gradle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[反转部分单向链表]]></title>
    <url>%2F2018%2F01%2F08%2F%E5%8F%8D%E8%BD%AC%E9%83%A8%E5%88%86%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[反转部分单向链表比反转整个单链表略显复杂，具体思路如下： 规定部分链表的起始位置为from，结束位置为to，判断是否满足1&lt;=from&lt;=to&lt;=N（N为总节点数），不满足则世界返回头节点 找到第from-1个节点fPre和第to+1个节点tPos。fPre是要反转部分的前一个节点，tPos则是要反转部分的后一个节点。 如果fPre为null，说明反转部分是包含头节点的，则返回新的头节点，也就是没反转之前反转部分的最后一个几点，反转之后反转部分的第一个节点；如果fPre不为null，则返回旧的头节点 具体代码如下：123456789101112131415161718192021222324252627282930public Node reversePart(Node head, int from, int to) &#123; int len = 0; Node node1 = head; Node fPre = null; Node tPos = null; while (node1 != null) &#123; len ++; fPre = len==from - 1 ? node1 : fPre; tPos = len==to + 1 ? node1 : tPos; node1 = node1.next; &#125; if (from &gt; to || from &lt; 1 || to &gt; len) &#123; return head; &#125; node1 = fPre == null ? head : fPre.next; Node node2 = node1.next; node1.next = tPos; Node next = null; while (node2 != tPos) &#123; next = node2.next; node2.next = node1; node1 = node2; node2 = next; &#125; if (fPre != null) &#123; fPre.next = node1; return head; &#125; return node1; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[策略模式：再见if-else]]></title>
    <url>%2F2018%2F01%2F08%2F%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[组合模式也称为部分整体模式，它的作用是将一组相似的对象看作一个对象处理，然后提供同一的方法去访问相应对象，这样可以很容易地得到一个树形结构，操作系统中的文件就可以抽象成一个经典的组合模式，如下： 抽象根节点：抽象文件类1234567891011121314151617public abstract class Dir &#123; protected List&lt;Dir&gt; dirs = new ArrayList&lt;&gt;(); private String name; public Dir(String name) &#123; this.name = name; &#125; public abstract void addDir(Dir dir); public abstract void removeDir(Dir dir); public abstract void clear(); public abstract void print(); public abstract List&lt;Dir&gt; getFiles(); public String getName() &#123; return name; &#125;&#125; 具体枝干节点：文件夹类12345678910111213141516171819202122232425262728293031323334353637383940public class Folder extends Dir &#123; public Folder(String name) &#123; super(name); &#125; @Override public void addDir(Dir dir) &#123; dirs.add(dir); &#125; @Override public void removeDir(Dir dir) &#123; dirs.remove(dir); &#125; @Override public void clear() &#123; dirs.clear(); &#125; @Override public void print() &#123; System.out.print(getName()+&quot;(&quot;); Iterator&lt;Dir&gt; iterator = dirs.iterator(); while (iterator.hasNext()) &#123; Dir dir = iterator.next(); dir.print(); if (iterator.hasNext()) &#123; System.out.print(&quot;,&quot;); &#125; &#125; System.out.print(&quot;)&quot;); &#125; @Override public List&lt;Dir&gt; getFiles() &#123; return dirs; &#125;&#125; 具体叶子节点：文件类123456789101112131415161718192021222324252627282930public class File extends Dir &#123; public File(String name) &#123; super(name); &#125; @Override public void addDir(Dir dir) &#123; throw new UnsupportedOperationException(&quot;文件对象不支持该操作&quot;); &#125; @Override public void removeDir(Dir dir) &#123; throw new UnsupportedOperationException(&quot;文件对象不支持该操作&quot;); &#125; @Override public void clear() &#123; throw new UnsupportedOperationException(&quot;文件对象不支持该操作&quot;); &#125; @Override public void print() &#123; System.out.print(getName()); &#125; @Override public List&lt;Dir&gt; getFiles() &#123; throw new UnsupportedOperationException(&quot;文件对象不支持该操作&quot;); &#125;&#125; 具体使用如下： 12345678910public class Main &#123; public static void main(String[] args) &#123; Dir diskC = new Folder(&quot;C&quot;); diskC.addDir(new File(&quot;test.txt&quot;)); Dir dirWin = new Folder(&quot;Windows&quot;); dirWin.addDir(new File(&quot;explorer.exe&quot;)); diskC.addDir(dirWin); diskC.print(); &#125;&#125; 结果 组合文件十分适合数据对象之间存在着递归关系的情景]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gradle的安装和Hello World]]></title>
    <url>%2F2018%2F01%2F07%2Fhellogradle%2F</url>
    <content type="text"><![CDATA[gradle是Android的自动化构建工具，开发Android有很多地方在跟gradle打交道，而因为gradle所采用的Groovy也是一个很庞大的体系，如果希望学习Groovy来提升Android的技术能力的话可能有些不值，所以最好的方法还是直接学习gradle gradle安装gradle的下载地址如下： gradle官网 安装官网的步骤一步步来就可以了，官网中提倡使用包管理器进行下载，即使是在windows下，也推荐使用choco来进行下载管理，当然，网上也有很多教程是下载好之后自己配置环境的 安装好之后在intellij下新建一个Goovy项目（注意是Goovy而不是gradle），选择gradle的话会帮我们配置很多东西，最初并不需要它在新建完项目之后，我们在项目根目录下创建一个build.gradle文件，输入以下代码： 12345task hello&#123; doLast&#123; println&apos;hello world!&apos; &#125;&#125; 这里我们定义了一个hello任务，doLast则代表了在Task执行之后的回调 使用gradle运行代码只需要在Terminal下执行 gradle -q hello 其中-q代表了日志级别，hello则是任务名，结果如下：]]></content>
      <categories>
        <category>gradle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单例模式的使用]]></title>
    <url>%2F2018%2F01%2F06%2FIntance%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式适用于重新构造消耗大，又时常需要用到的类，一般又懒汉模式、饿汉模式、DCL模式和静态内部类模式这几种 懒汉模式123456789101112public class Example &#123; private static Example example; private Example()&#123; &#125; public static synchronized Example getInstance() &#123; if (example == null) &#123; example = new Example(); &#125; return example; &#125;&#125; 懒汉模式在每次获得单例的时候都使用synchronized（加内部锁方式的同步）关键字进行同步，消耗较大饿汉模式12345678public class Example &#123; private static final Example example = new Example(); private Example()&#123; &#125; public static Example getInstance() &#123; return example; &#125;&#125; 饿汉模式没有同步的问题，每次获取到的都是同一单例，但不管有没有用到都会创建对象，浪费空间DCL模式12345678910111213141516public class Example &#123; private static volatile Example example = null; private Example()&#123; &#125; public static Example getInstance() &#123; if (example == null) &#123; synchronized (Example.class) &#123; if (example == null) &#123; example = new Example(); &#125; &#125; &#125; return example; &#125;&#125; DCL方法有上面两种单例方法的优点，既保证了使用时才进行初始化，又保证了线程安全，但在某些情况下会有小概率出错，尽管如此，这仍然是用得最广泛的单例方法静态内部类模式12345678910111213public class Example &#123; private Example()&#123; &#125; public static Example getInstance() &#123; return ExampleHolder.example; &#125; private static class ExampleHolder &#123; private static final Example example = new Example(); &#125;&#125; 既保证了线程安全，也达到了节省资源的目的，是推荐使用的单例模式枚举模式123456public enum Example &#123; INSTANCE; public void doSomething()&#123; ... &#125;&#125; 枚举模式是实现单例最简单的模式，因为枚举本身就具有线程安全性，所以我们无需担心线程安全的问题，而且枚举安全也避免了序列化时重新生成对象的问题（当然，这个问题我们一般碰不到）总结，单例模式分成了上面几种，一般推荐使用静态内部类实现单例，DCL模式虽然是应用最为广泛的模式，但因为java的内存模型还存在着小概率的问题，而Google官方不推荐使用枚举模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[策略模式：再见if-else]]></title>
    <url>%2F2018%2F01%2F05%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%86%8D%E8%A7%81if-else%2F</url>
    <content type="text"><![CDATA[在软件开发中，我们时常用到if-else来对进行条件判断，然后再进行相应的操作，但这样做会使得项目再日后的维护中出现困难，所以，当遇到比较复杂的if-else结构的时候，使用策略模式是很好的选择 举一个简单的计算小例子，如对两个数进行加减乘除第一步，定义计算接口123public interface CalculateStrategy &#123; int calculateComeout(int number1, int number2);&#125; 第二步，实现策略类 加法策略 123456public class PlusStrategy implements CalculateStrategy &#123; @Override public int calculateComeout(int number1, int number2) &#123; return number1 + number2; &#125;&#125; 减法策略 123456public class MinusStrategy implements CalculateStrategy &#123; @Override public int calculateComeout(int number1, int number2) &#123; return number1 - number2; &#125;&#125; 实例运行1234567public class Main &#123; public static void main(String[] args) &#123; int number1 = 20, number2 = 10; new PlusStrategy().calculateComeout(number1, number2); new MinusStrategy().calculateComeout(number1,number2); &#125;&#125; 当然，这只是一个十分简单的实例，再实际应用中远没有这么“鸡肋”，比如我曾经开发过的一个小项目 策略模式实战 OpeningStartAnimation是一个开屏动画View，所以这里的策略模式是与绘画策略相关的 绘画策略接口 1234567891011121314151617181920212223242526272829303132333435public interface DrawStrategy &#123; /** * 绘制app名称文字 * @param canvas 画布 * @param fraction 完成时间百分比 * @param colorOfAppName 字体颜色 * @param name 文字 * @param widthAndHeightOfView view的宽和高 */ void drawAppName(Canvas canvas, float fraction, String name, int colorOfAppName, WidthAndHeightOfView widthAndHeightOfView); /** * 绘制app图标 * @param canvas 画布 * @param fraction 完成时间百分比 * @param colorOfIcon 绘制图标颜色 * @param icon 图标 * @param widthAndHeightOfView view的宽和高 */ void drawAppIcon(Canvas canvas, float fraction, Drawable icon, int colorOfIcon, WidthAndHeightOfView widthAndHeightOfView); /** * 绘制app一句话描述 * @param canvas 画布 * @param fraction 完成时间百分比 * @param statement 一句话描述 * @param colorOfStatement 字体颜色 * @param widthAndHeightOfView view的宽和高 */ void drawAppStatement(Canvas canvas, float fraction, String statement, int colorOfStatement, WidthAndHeightOfView widthAndHeightOfView);&#125; 其中的一个具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138public class LineDrawStrategy implements DrawStrategy &#123; public LineDrawStrategy()&#123; &#125; @Override public void drawAppName(Canvas canvas, float fraction, String name, int colorOfAppName, WidthAndHeightOfView widthAndHeightOfView) &#123; canvas.save(); Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG); paint.setColor(colorOfAppName); paint.setStyle(Paint.Style.STROKE); paint.setStrokeWidth(5); paint.setTextSize(50); paint.setStrokeJoin(Paint.Join.ROUND); paint.setTextAlign(Paint.Align.LEFT); float x = widthAndHeightOfView.getWidth() / 2; int centerY = widthAndHeightOfView.getHeight() / 2; float y = centerY - 275; Path path = new Path(); path.moveTo(x, y); if (fraction &lt;= 0.50) &#123; path.lineTo(x, y + (25 + name.length() + 250) * (fraction / 0.50f)); canvas.drawPath(path, paint); &#125; else &#123; path.lineTo(x, y + (25 + name.length() + 250) * ((1 - fraction)/ 0.50f)); canvas.drawPath(path, paint); paint.setStyle(Paint.Style.FILL); canvas.drawText(name, x + 20, y + 150, paint); &#125; canvas.restore(); &#125; @Override public void drawAppIcon(Canvas canvas, float fraction, Drawable icon, int colorOfIcon, WidthAndHeightOfView widthAndHeightOfView) &#123; int centerX = widthAndHeightOfView.getWidth() / 2; int centerY = widthAndHeightOfView.getHeight() / 2; Bitmap bitmap = ((BitmapDrawable) icon).getBitmap(); Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG); paint.setColor(colorOfIcon); paint.setStrokeWidth(3); paint.setStrokeJoin(Paint.Join.ROUND); paint.setStyle(Paint.Style.STROKE); float bitmapLeft = centerX - 250; float bitmapRight = bitmapLeft + bitmap.getWidth() * 1.7f; float bitmapTop = centerY - 250; float bitmapBottom = bitmapTop + bitmap.getHeight() * 1.7f; canvas.save(); if (fraction &lt;= 0.75) &#123; float newfraction = fraction / 0.75f; if (newfraction &lt;= 0.25) &#123; canvas.drawLine(bitmapLeft, bitmapBottom, bitmapLeft, bitmapBottom - (bitmapBottom - bitmapTop) * (newfraction / 0.25f), paint); // path.lineTo(bitmapLeft, bitmapBottom + (bitmapBottom - bitmapTop) * (newfraction / 0.25f)); &#125; else &#123; canvas.drawLine(bitmapLeft, bitmapBottom, bitmapLeft, bitmapTop, paint); // path.lineTo(bitmapLeft, bitmapTop); &#125; if (newfraction &gt; 0.25) &#123; if (newfraction &lt;= 0.50) &#123; canvas.drawLine(bitmapLeft, bitmapTop, bitmapLeft + (bitmapRight - bitmapLeft) * ((newfraction - 0.25f)/0.25f), bitmapTop, paint); // path.lineTo(bitmapLeft + (bitmapRight - bitmapLeft) * ((newfraction - 0.25f)/0.25f), // bitmapTop); &#125; else &#123; canvas.drawLine(bitmapLeft, bitmapTop, bitmapRight, bitmapTop, paint); // path.lineTo(bitmapRight, bitmapTop); &#125; &#125; if (newfraction &gt; 0.50) &#123; if (newfraction &lt;= 0.75) &#123; canvas.drawLine(bitmapRight, bitmapTop, bitmapRight, bitmapTop + (bitmapBottom - bitmapTop) * ((newfraction - 0.50f) / 0.25f), paint); //path.lineTo(bitmapRight, bitmapTop + (bitmapBottom - bitmapTop) * ((fraction - 0.50f) / 0.25f)); &#125; else &#123; canvas.drawLine(bitmapRight, bitmapTop, bitmapRight, bitmapBottom, paint); //path.lineTo(bitmapRight, bitmapBottom); &#125; &#125; if (newfraction &gt; 0.75) &#123; if (newfraction &lt;= 1) &#123; canvas.drawLine(bitmapRight, bitmapBottom, bitmapRight - (bitmapRight - bitmapLeft) * ((newfraction - 0.75f)/ 0.25f), bitmapBottom, paint); // path.lineTo(bitmapLeft + (bitmapRight - bitmapLeft) * ((fraction - 0.75f)/ 0.25f), // bitmapBottom); &#125; else &#123; canvas.drawLine(bitmapRight, bitmapBottom, bitmapLeft, bitmapBottom, paint); // path.lineTo(bitmapLeft, bitmapBottom); &#125; &#125; &#125; canvas.restore(); canvas.save(); if (fraction &gt; 0.75) &#123; canvas.clipRect(bitmapLeft + (bitmap.getWidth()/2f) * ((1 - fraction) /0.25f), bitmapTop + (bitmap.getHeight()/2f)* ((1 - fraction) / 0.25f), bitmapRight - (bitmap.getWidth()/2f) * ((1 - fraction) /0.25f), bitmapBottom - (bitmap.getHeight()/2f)* ((1 - fraction) / 0.25f)); Matrix matrix = new Matrix(); matrix.postScale(1.7f, 1.7f, (bitmapLeft + bitmapRight) * 0.5f, (bitmapTop + bitmapBottom) * 0.5f); canvas.concat(matrix); canvas.drawBitmap(bitmap, (bitmapLeft + bitmapRight) / 2 - bitmap.getWidth() / 2, (bitmapTop + bitmapBottom) / 2 - bitmap.getHeight() / 2, paint); &#125; canvas.restore(); &#125; @Override public void drawAppStatement(Canvas canvas, float fraction, String statement, int colorOfStatement, WidthAndHeightOfView widthAndHeightOfView) &#123; canvas.save(); int width = widthAndHeightOfView.getWidth(); int height = widthAndHeightOfView.getHeight(); Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG); paint.setColor(colorOfStatement); paint.setStyle(Paint.Style.STROKE); paint.setTextSize(45); paint.setTextSkewX(-0.2f); paint.setTextAlign(Paint.Align.CENTER); RectF rectF = new RectF(width / 4 - statement.length(), height * 7 / 8, width * 3, height); if (fraction &lt;= 0.60f) &#123; Path path = new Path(); path.addArc(rectF,193,40 * fraction * 1.67f); canvas.drawPath(path, paint); &#125; else &#123; Path path = new Path(); path.addArc(rectF, 193, 40); canvas.drawPath(path, paint); canvas.drawTextOnPath(statement, path, 0, 0, paint); &#125; canvas.restore(); &#125;&#125; 示例 这是选择策略的方法123456789/** * 开放绘制策略接口，可由用户自行定义 * @param drawStrategy 绘制接口 * @return Builder对象 */ public Builder setDrawStategy(DrawStrategy drawStrategy) &#123; mOpeningStartAnimation.mDrawStrategy = drawStrategy; return this; &#125; 策略的具体实现 12345678910111213@Override protected void onDraw(Canvas canvas) &#123; canvas.drawColor(colorOfBackground); //绘制背景色 super.onDraw(canvas); mWidthAndHeightOfView.setHeight(getHeight()); mWidthAndHeightOfView.setWidth(getWidth()); mDrawStrategy.drawAppIcon(canvas, fraction, mDrawable, colorOfAppIcon, mWidthAndHeightOfView); mDrawStrategy.drawAppName(canvas, fraction, appName, colorOfAppName, mWidthAndHeightOfView); mDrawStrategy.drawAppStatement(canvas, fraction, appStatement, colorOfAppStatement, mWidthAndHeightOfView); &#125; 具体项目可见 项目地址]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[两个单链表相交问题总结]]></title>
    <url>%2F2018%2F01%2F04%2F%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[两个单链表问题123解决了两个单链表相交问题，总体思路如下： 先判断两个单链表是否有环，然后根据两个单链表是否有环进行分类讨论两个单链表是否相交，整体代码如下： 数据结构1234567public class Node&#123; public int value; public Node next; public Node(int value) &#123; this.value = data; &#125;&#125; 主方法1234567891011121314public Node getIntersectNode(Node head1,Node head2) &#123; if (head == null || head2 == null) &#123; return null; &#125; Node loop1 = judgeLoop(head1); Node loop2 = judgeLoop(head2); if (loop1 == null &amp;&amp; loop2 == null) &#123; return noLoop(head1,head2); &#125; if (loop1 != null &amp;&amp; loop2 != null) &#123; return twoLoop(head1,loop1,head2,loop2); &#125; return null;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[由两个栈实现一个队列]]></title>
    <url>%2F2018%2F01%2F03%2F%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[栈和队列都是属于基本的数据结构，而栈的特点是后进先出，队列的特点是先进后出，我们只需要使用两个栈就可以实现从后进先出到先进先出 具体的实现算法如下：123456789101112131415161718192021222324public class TwoStackQueue &#123; public Stack&lt;Integer&gt; firstStack; public Stack&lt;Integer&gt; secondStack; public TwoStackQueue() &#123; firstStack = new Stack&lt;&gt;(); secondStack = new Stack&lt;&gt;(); &#125; public void addInt(Integer integer) &#123; firstStack.push(integer); &#125; public Integer getInt() &#123; if (firstStack.empty()&amp;&amp;secondStack.empty()) &#123; throw new RuntimeException(&quot;No int in the stack!&quot;); &#125;else if(secondStack.empty()) &#123; while (!firstStack.empty()) &#123; secondStack.push(firstStack.pop()); &#125; &#125; return secondStack.pop(); &#125;&#125; 这里只实现了stack的pop操作，如果像实现peek操作的话只需再实现一遍，把pop改为peek即可]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[删除链表的中间节点和a/b处的节点]]></title>
    <url>%2F2018%2F01%2F03%2F%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[删除链表的中间节点这道题的解题思路还是比较简单的，我们只需用两个指针，一个指针每次走两步，而另一个指针每次走一步，当走两步的指针走到尽头时，另一个指针指向的即为中间节点的前驱节点 具体算法如下：12345678910111213141516public Node removeMidNode(Node head) &#123; if (head == null || head.next == null) &#123; return head; &#125; if (head.next.next == null) &#123; return head.next; &#125; Node pre = head; Node cur = head.next.next; while (cur.next != null &amp;&amp; cur.next.next != null) &#123; pre = pre.next; cur = cur.next.next; &#125; pre.next = pre.next.next; return head; &#125; 删除链表a/b处的节点这是删除中间节点的进阶问题，具体思路如下： 首先遍历链表，得到长度n，计算 double r = ((double)(a*n))/((double)b)的值，r向上取整之后的整数值代表该删除的节点 知道该删除的节点数之后找到该节点删除即可 具体算法如下： 1234567891011121314151617181920212223public Node removeByRatio(Node head, int a, int b) &#123; if (a &lt; 1 || a &gt; b) &#123; return head; &#125; int n = 0; Node cur = head; while (cur != null) &#123; n++; cur = cur.next; &#125; n = (int) (Math.ceil((double)(a * n))/(double)b); if (n == 1) &#123; head = head.next; &#125; if (n &gt; 1) &#123; cur = head; while (--n != 1) &#123; cur = cur.next; &#125; cur.next = cur.next.next; &#125; return head; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[两个单链表相交问题3：判断两个有环链表是否相交]]></title>
    <url>%2F2018%2F01%2F03%2F%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E9%97%AE%E9%A2%983%2F</url>
    <content type="text"><![CDATA[若两个链表是有环的，则问题1当中我们就可以得到链表1和链表2的两个入环节点loop1和loop2，这是前提条件，具体解题思路如下： 若loop1==loop2，则说明两个链表是入环节点一样的相交，我们可以使用在问题2中使用的方法来找出入环节点（其实已经找出来了，就是loop1和loop2），若loop1！=loop2，则有可能是不相交或者入环节点不一样的相交，如下： 让链表1从loop1出发，若在回到loop1之前没有遇到loop2，则说明两个链表没有相交 让链表1从loop1出发，若在回到loop1之前遇到loop2，则说明两个链表是入环节点不一样的相交 具体算法如下：1234567891011121314151617181920212223242526272829303132333435363738public Node twoLoop(Node head1, Node loop1, Node head2, Node loop2) &#123; Node cur1 = null; Node cur2 = null; if (loop1 == loop2) &#123; cur1 = head1; cur2 = head2; int n = 0; while (cur1 != loop1) &#123; n++; cur1 = cur1.next; &#125; while (cur2 != loop2) &#123; n--; cur2 = cur2.next; &#125; cur1 = n &gt; 0? head1 : head2; cur2 = cur1 == head1 ? head2 :head1; n = Math.abs(n); while (n != 0) &#123; n--; cur1 = cur1.next; &#125; while (cur1 != cur2) &#123; cur1 = cur1.next; cur2 = cur2.next; &#125; return cur1; &#125; else &#123; cur1 = loop1.next; while (cur1 != loop1) &#123; if (cur1 == loop2) &#123; return loop1; &#125; cur1 = cur1.next; &#125; &#125; return null;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式中的车轮战-责任链模式]]></title>
    <url>%2F2018%2F01%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%BD%A6%E8%BD%AE%E6%88%98-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[责任链模式在Android中的应用莫过于事件分发了，ViewGroup对事件分别给子View，从ViewTree的顶部至上而下地进行处理，直到事件被消化为止，这种方法在Android广播中也能看到 责任链模式的实现分为以下几个部分 请求者12345678910111213141516public class Request &#123; private Object object; private int RequestLevel; public Request(Object object,int requestLevel) &#123; this.object = object; this.RequestLevel = requestLevel; &#125; public Object getObject() &#123; return object; &#125; public int getRequestLevel() &#123; return RequestLevel; &#125;&#125; 这里的object在实际开发当中我们可以换成其他自定义的对象，如Android中的Message和Handler那样 抽象处理者12345678910111213141516171819202122public abstract class AbstractHandler &#123; private AbstractHandler nextHandler; public final void handleRequest(Request request) &#123; if (getHandlerLevel() == request.getRequestLevel()) &#123; handle(request); &#125; else &#123; if (nextHandler != null) &#123; nextHandler.handleRequest(request); &#125; else &#123; System.out.println(&quot;No handler can handle it!&quot;); &#125; &#125; &#125; public void setNextHandler(AbstractHandler nextHandler) &#123; this.nextHandler = nextHandler; &#125; protected abstract int getHandlerLevel(); protected abstract void handle(Request request);&#125; 处理者 处理者1 12345678910public class Handler1 extends AbstractHandler &#123; @Override protected void handle(Request request) &#123; System.out.println(&quot;handler1 handle it&quot;); &#125; @Override protected int getHandlerLevel() &#123; return 1; &#125;&#125; 处理者2 1234567891011public class Handler2 extends AbstractHandler &#123; @Override protected int getHandlerLevel() &#123; return 2; &#125; @Override protected void handle(Request request) &#123; System.out.println(&quot;handler2 handle it&quot;); &#125;&#125; 使用123456789public class Main &#123; public static void main(String[] args) &#123; AbstractHandler handler1 = new Handler1(); AbstractHandler handler2 = new Handler2(); handler1.setNextHandler(handler2); Request request = new Request(&quot;request&quot;,2); handler1.handleRequest(request); &#125;&#125; 这样处理事件就会沿着责任链一个个下去，直到被处理者处理或没有处理者为止]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Github桌面版实现最简单的hexo部署到Github.io]]></title>
    <url>%2F2018%2F01%2F02%2F%E7%94%A8Github%E6%A1%8C%E9%9D%A2%E7%89%88%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github%2F</url>
    <content type="text"><![CDATA[今天准备把hexo部署到github.io的时候参考了网上几篇文章，发现写的都十分地费劲，不是老是出错，就是步骤麻烦，特地写一篇来记录一下我的方法，当然，这篇文章是建立在在本地已经写好hexo的情况下的 首先，下载github桌面版 地址如下：GitHub桌面版 嗯 做完这一步之后，再github上创建项目（这一步大家应该都已经做完了，没做完的话可以参考一下这里Github.io 第二步，用github桌面版（要登陆）把项目clone下来 clone到一个空目录，之后就把hexo根目录下的文件全都复制黏贴到这个clone下来的目录下就好了，这样做不会有权限的冲突（哈哈哈哈）再后一步，安装hexo-deployer-git这一步很简单，在根目录执行如下命令 npm install hexo-deployer-git –save 然后修改hexo的配置文件（注意是hexo的不是theme的）12345deploy: type: git repo: &lt;repository url&gt; //SSH branch: [branch] //当前的分支，一般是master message: [message] // 可不填 SSH可以在这里获得，HTTPS和SSH可用右上角切换 最后一步，在hexo的根目录下执行如下命令123$ hexo clean$ hexo g$ hexo d 成功的话就可以在github的项目setting里面看到自己的博客主页了！如果要自己的域名的话，可以这样做参考]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[两个单链表相交问题2：判断两个无环链表是否相交]]></title>
    <url>%2F2018%2F01%2F02%2F%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E9%97%AE%E9%A2%982%2F</url>
    <content type="text"><![CDATA[这个问题是第一个问题的后续，判断链表无环的话就可以用这个方法做，因为两个无环的链表相交，最后的一个节点是一样的，用这个思路就可以做出来 总体思路如下： 链表1从头节点开始，一次走一步，记录从头节点走到最后节点的步数n1，并记录最后一个节点end1，链表2则相应地记录n2和end2 若end1！=end2，则两个链表不相交，若end1==end2，则比较n1和n2的大小来得出链表1和链表2哪个长，然后分别返回头节点，短的链表先走n1与n2相差的步数 两个链表同时一次一步，相遇节点即为第一个相交节点 具体代码如下1234567891011121314151617181920212223242526272829303132public Node noLoop(Node head1, Node head2) &#123; if (head1 == null &amp;&amp; head2 == null) &#123; return null; &#125; Node cur1 = head1; Node cur2 = head2; int n = 0; while (cur1.next != null) &#123; cur1 = cur1.next; n++; &#125; while (cur2.next != null) &#123; cur2 = cur2.next; n--; &#125; if (cur1 != cur2) &#123; return null; &#125; cur1 = n &gt; 0? head1:head2; cur2 = head1 == cur1? head2:head1; n = Math.abs(n); while (n != 0) &#123; cur1 = cur1.next; n--; &#125; while (cur1 != cur2) &#123; cur1 = cur1.next; cur2 = cur2.next; &#125; return cur1; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java项目构建：基础单项目]]></title>
    <url>%2F2018%2F01%2F02%2FJava%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%8D%95%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[构建一个Java项目其实十分地简单，只需在gradle中进行配置，然后执行就可以了 Java插件要配置一个Java项目，首先我们地安装Java的插件，在gradle.build文件顶部写入以下代码1apply plugin: &apos;java&apos; 再执行任务安装插件 这样Java的插件就安装完毕了 Android插件在Android开发中，我们在gradle.build文件中可以看到这样的代码 1apply plugin: &apos;com.android.application&apos; 这和刚刚示例的Java插件是同样的用法，不过Android studio在初始化项目的时候已经帮我们默认执行了动作，所以我们需要手动地执行 依赖外部依赖Java项目中的外部依赖其实和Android项目当中的外部依赖是一样的，都是添加maven库等操作，如下所示： 1234repositories &#123; google() jcenter() &#125; 加入依赖在Android项目中，这个一般在我们使用第三方库的时候用到很多，当然，即使我们不使用第三方库，Android studio在初始化时也会为我们配置很多默认的依赖项 123456789dependencies &#123; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos; testImplementation &apos;junit:junit:4.12&apos; androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos; androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos; compile project(&quot;:openingstartanimation&quot;)&#125;]]></content>
      <categories>
        <category>gradle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[两个单链表相交问题1：判断链表是否有环]]></title>
    <url>%2F2018%2F01%2F01%2F%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E9%97%AE%E9%A2%981%2F</url>
    <content type="text"><![CDATA[本题是两个单链表问题当中的第一个问题：判断一个链表是否有环，若有，则返回第一个相交节点，也就是入环节点，实现算法具体如下： 1234567891011121314151617181920public Node judgeLoop(Node head) &#123; if (head == null || head.next == null|| head.next.next == null) &#123; return null; &#125; Node node1 = head.next; Node node2 = head.next.next; while (node1 != node2) &#123; if (node2.next == null|| node2.next.next == null) &#123; return null; &#125; node2 = node2.next.next; node1 = node1.next; &#125; node2 = head; while (node1 != node2) &#123; node1 = node1.next; node2 = node2.next; &#125; return node1; &#125; 思路为： 设置两个指针，一快一慢，快的一次走两步，而慢指针每次走一步 若快指针走到尽头，则链表无环，若有环则两个指针相遇 相遇则快指针回到头结点再次出发，速度变为一次一步，慢指针不变 两个指针再次相遇的节点为入环节点]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用intellij编写react native]]></title>
    <url>%2F2017%2F12%2F30%2F%E4%BD%BF%E7%94%A8Intellij%E7%BC%96%E5%86%99react%20native%2F</url>
    <content type="text"><![CDATA[今天看到react-native更新到了0.51版本，按照中文文档在原有Android项目引入react native发现运行不出来，莫名奇妙地崩溃，于是决定还是从零开始构建react-native app，网上一般推荐使用sublime来编辑项目，但是总感觉使用地十分不顺手，最后还是决定使用intellij来开发，意外地发现十分好用！ 首先，intellij的地址如下：intellij地址 社区版是免费的，平常开发也够用，如果想用Ultimate版本的建议购买正版，如果是学生的话可以看看破解教程（免费需要国际学生证）第二步，在intellij下创建空项目 名字什么的就随意了然后，我们根据官方文档来创建项目react native中文文档 因为在terminal中直接创建项目实在是太爽了，这也是我放弃sublime的原因，只要这样就可以（注意先要把terminal切换到上一层目录） 最后需要注意的一点是，如果使用真机调试可以需要指定端口，这也可以在官方文档中直接找到 最后，其实除了intellij，pythonCharm是直接支持react native的开发的，不过因为在intellij中调试java代码会更加方便，如果想使用原生模块的话还是更推荐使用intellij]]></content>
      <categories>
        <category>react native</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[react native的navigation实现]]></title>
    <url>%2F2017%2F12%2F27%2Freact%20native%20%E4%B8%89%E7%A7%8D%E5%AF%BC%E8%88%AA%E6%A0%8F%2F</url>
    <content type="text"><![CDATA[在react native的开发中，我们不需要像在原生开发一样使用intent来切换各个Activity，也能很方便地实现viewpager和抽屉式导航栏的效果，facebook官方提供了三种导航栏样式 第一种:StackNavigator,这个导航栏和我们在原生开发中使用intent启动另一个全屏的Activity是差不多的效果，当然动画效果可能并不怎么一样 实现代码如下： 1234567891011121314const RootNavigator = StackNavigator(&#123; first: &#123; screen: first, navigationOptions: &#123; headerTitle: &apos;first&apos;, // 设置页面的header &#125;, &#125;, second: &#123; screen: second, navigationOptions: &#123; headerTitle: &apos;second&apos;, // 设置页面的header &#125;, &#125;,&#125;); first和second就是两个class了.. 如果需要在两个页面之间跳转，我们只需要在设置一个按钮，把按钮的点击事件设置为跳向下一个页面就可以了，如下：1234&lt;Button onPress=&#123;() =&gt; navigation.navigate(&apos;second&apos;)&#125; title=&quot;to second&quot; /&gt; 这样点击按钮就会跳转到second页面了，同理也可以在second页面中设置按钮跳转 第二种：TabNavigator，这就是和viewpager同样效果的导航栏了只需要把第一种的StackNavigator换成TabNavigator就可以，像这样： 1234567891011121314const RootNavigator = StackNavigator(&#123; first: &#123; screen: first, navigationOptions: &#123; headerTitle: &apos;first&apos;, // 设置页面的header &#125;, &#125;, second: &#123; screen: second, navigationOptions: &#123; headerTitle: &apos;second&apos;, // 设置页面的header &#125;, &#125;,&#125;); 效果图如下： 第三种：DrawerNavigator，抽屉式导航栏和上面一样，只需要替换成DrawerNavigator就可以了，代码就不放出来了，效果如下：]]></content>
      <categories>
        <category>react native</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpeningStartAnimation - Android开屏动画view]]></title>
    <url>%2F2017%2F12%2F26%2FOpeningStartAnimation%20-%20Android%E5%BC%80%E5%B1%8F%E5%8A%A8%E7%94%BBview%2F</url>
    <content type="text"><![CDATA[项目地址https://github.com/JoshuaRogue/FancyView 使用后效果如下： 使用方法： 在项目中添加依赖 1compile &apos;site.gemus:openingstartanimation:1.0.0&apos; //在gradle中导入项目 使用 OpeningStartAnimation.Builder(Context context) //context为当前活动的baseContext OpeningStartAnimation.show(Activity mactivity) //mactivity为当前显示的activity123OpeningStartAnimation openingStartAnimation = new OpeningStartAnimation.Builder(this) .create(); openingStartAnimation.show(this); 默认的效果为图1，可使用Builder.setDrawStategy() 方法指定其他三种效果，图2、3、4分别对应了RedYellowBlueDrawStrategy，LineDrawStrategy和RotationDrawStrategy三种动画效果，也可以自定义接口实现动画，如下所示1234567891011121314151617OpeningStartAnimation openingStartAnimation = new OpeningStartAnimation.Builder(this) .setDrawStategy(new DrawStrategy() &#123; @Override public void drawAppName(Canvas canvas, float fraction, String name, int colorOfAppName, WidthAndHeightOfView widthAndHeightOfView) &#123; &#125; @Override public void drawAppIcon(Canvas canvas, float fraction, Drawable icon, int colorOfIcon, WidthAndHeightOfView widthAndHeightOfView) &#123; &#125; @Override public void drawAppStatement(Canvas canvas, float fraction, String statement, int colorOfStatement, WidthAndHeightOfView widthAndHeightOfView) &#123; &#125; &#125;).create(); 也可以通过其他set函数指定图标，应用名，应用一句话描述等等，如下所示12345678910OpeningStartAnimation openingStartAnimation = new OpeningStartAnimation.Builder(this) .setAppIcon() //设置图标 .setColorOfAppIcon() //设置绘制图标线条的颜色 .setAppName() //设置app名称 .setColorOfAppName() //设置app名称颜色 .setAppStatement() //设置一句话描述 .setColorOfAppStatement() // 设置一句话描述的颜色 .setAnimationInterval() // 设置动画时间间隔 .setAnimationFinishTime() // 设置动画的消失时长 .create(); 觉得好用的话别忘了赏个star哦，github地址如下 https://github.com/JoshuaRogue/FancyView]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java项目构建：多项目]]></title>
    <url>%2F2017%2F12%2F21%2FJava%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%EF%BC%9A%E5%A4%9A%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[多项目构建 其实构建Java多项目和单项目差不多，唯一需要改变的就是在setting.gradle中加上如下代码1include &apos;:app&apos;, &apos;:openingstartanimation&apos; 其中app是我构建的主项目，而openingstartanimation则是依赖项目 项目之间的依赖关系例如，在上一个项目中app与openingstartanimation这两个项目，app项目是依赖于openingstartanimation项目的，也就是说，app中需要用到openingstartanimation中的类和函数，我们应该这样 123ependencies &#123; compile project(&quot;:openingstartanimation&quot;)&#125; 在app项目的build.gradle中加入以上代码，app就依赖于openingstartanimation了]]></content>
      <categories>
        <category>gradle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android引入react native]]></title>
    <url>%2F2017%2F12%2F17%2FAndroid%E5%BC%95%E5%85%A5react%20native%2F</url>
    <content type="text"><![CDATA[前几天看react native中文文档准备自己跑一下hello world，发现在中文文档里有几处小错误，为了让更多的小伙伴顺利地把react native引入Android项目，把这次烦心的经历分享出来首先，中文开发文档奉上 http://reactnative.cn/docs/0.31/getting-started.html 需要注意我们得手动调到最新的文档，写这篇博客时为0.50问题出现在1.setBundleAssetName(&quot;index.android.bundle&quot;) .setJSMainModuleName(&quot;index.android&quot;) 这里，笔者写时setJSMainModuleName这个方法已经不存在了，react native的迭代很快，我们只能用setJSMainModulePath() 这个方法替代，在这里文档中写的参数也并不正确，应该改为12.setBundleAssetName(&quot;index.bundle&quot;).setJSMainModulePath(&quot;index&quot;) 然后再在命令行中启用npm start就可以了，运行成功后如下：]]></content>
      <categories>
        <category>react native</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[发布Android开源项目到Jcenter库]]></title>
    <url>%2F2017%2F12%2F10%2F%E5%8F%91%E5%B8%83Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%88%B0Jcenter%E5%BA%93%2F</url>
    <content type="text"><![CDATA[我们在使用Android studio时，导入一个第三方开源库很方便，如果整个库已经被发布到Maven库时，我们只需要在MainActivity所在的build.gradle（注意不是最外层的）中添加依赖即可，像这样12implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos; 这里只是举个例子，实际上这两个都是官方的库，在Android studio 3.0中不再默认使用compile而是使用implementation来引入，这里注意一下 如果我们想要把自己做的一个库发布到Maven库上，让其他人也能这么方便地使用的话， 我们应该把库中的文件独立出来成一个Android library，这样在后续打包的时候你就能把整个库独立打包，而不是和项目中其他的一些文件一起打包（比如说与库的实现无关的Activity和它的布局文件，还有一些其他的配置文件），像下面这样 在这里库的名字（红圈圈出来的）需要注意了，这个就是在将来引入库的时候，两个‘：’之间的库名称，像com.squareup.okhttp:okhttp:2.0.0，’:’后面的okhttp就是库的名字，这关系到将来发布之后时怎么个样子，所以特地拿出来说一下。接下来就是把去完成这个库了，完成之后你会发现在主应用(就是app文件夹中的)，比如说在MainActivity中，是无法使用这个库的，因为我们还少了一步，在主应用的依赖里加入这个库，因为加入的是本地库，所以只需要这么写1compile project(&quot;:openingstartanimation&quot;) openingstartanimation是我自己写的库名称，在这里填入你自己的 已经做好这一步的话（其实如果不需要app使用这个库的话上一步可以不做，不过我们总得测试一下自己的库哈哈哈哈），就可以做一些把库发布到Jcenter上了。再Jcenter上注册账号，地址如下：https://bintray.com/signup/oss （这个是开源项目的注册） 我在注册的时候遇到了个小坑，使用国内的qq邮箱注册无法被识别，使用谷歌邮箱注册也老是出错，建议大家直接使用边上的 sign up with google 或者直接使用 sign in with google ,这样的出错几率比较小。注册成功之后进入个人中心，点左上角的edit进入个人配置，找到apikey，这个等等会用到。之后再回退到上一个页面，先 add new Repository 创建自己的maven库，这里的name一栏填的名字需要注意一下，这在后面也会用到，建议直接填maven，然后type的类型也是maven，开源协议则一般选择Apache2.0，创建完成之后再回到Android studio配置一下文件。第一步，在最外层的build.gradle中加入依赖，如下123456789101112buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.0.1&apos; classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.4.1&apos; //新添加的 classpath &apos;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.2&apos; //新添加的 &#125;&#125; 第二步，在库中的build.gradle 中填写maven库的配置，下面是我的build.gradle的完整的内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109apply plugin: &apos;com.android.library&apos;apply plugin: &apos;com.github.dcendents.android-maven&apos;apply plugin: &apos;com.jfrog.bintray&apos;// This is the library version used when deploying the artifactversion = &quot;1.0.0&quot;def siteUrl = &apos;&apos; // 项目的主页def gitUrl = &apos;https://github.com/JoshuaRogue/FancyView.git&apos; // Git仓库的urlgroup = &quot;&quot; // Maven Group ID for the artifact，一般填你唯一的包名install &#123; repositories.mavenInstaller &#123; // This generates POM.xml with proper parameters pom &#123; project &#123; packaging &apos;aar&apos; // Add your description here name &apos;maven&apos; url siteUrl // Set your license licenses &#123; license &#123; name &apos;The Apache Software License, Version 2.0&apos; url &apos;http://www.apache.org/licenses/LICENSE-2.0.txt&apos; &#125; &#125; developers &#123; developer &#123; id &apos;&apos; //填写的一些基本信息 name &apos;&apos; email &apos;&apos; &#125; &#125; scm &#123; connection gitUrl developerConnection gitUrl url siteUrl &#125; &#125; &#125; &#125;&#125;task sourcesJar(type: Jar) &#123; from android.sourceSets.main.java.srcDirs classifier = &apos;sources&apos;&#125;task javadoc(type: Javadoc) &#123; source = android.sourceSets.main.java.srcDirs&#125;task javadocJar(type: Jar, dependsOn: javadoc) &#123; classifier = &apos;javadoc&apos; from javadoc.destinationDir&#125;artifacts &#123; archives javadocJar archives sourcesJar&#125;Properties properties = new Properties()properties.load(project.rootProject.file(&apos;local.properties&apos;).newDataInputStream())bintray &#123; user = properties.getProperty(&quot;bintray.user&quot;) key = properties.getProperty(&quot;bintray.apikey&quot;) configurations = [&apos;archives&apos;] pkg &#123; repo = &quot;&quot; //这是刚刚在创建maven库时的name name = &quot;&quot; //发布到JCenter上的项目名字 websiteUrl = siteUrl vcsUrl = gitUrl licenses = [&quot;Apache-2.0&quot;] publish = true &#125;&#125;javadoc &#123; //jav doc采用utf-8编码否则会报“GBK的不可映射字符”错误 options&#123; encoding &quot;UTF-8&quot; charSet &apos;UTF-8&apos; &#125;&#125;android &#123; compileSdkVersion 26 defaultConfig &#123; minSdkVersion 16 targetSdkVersion 26 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125;&#125;dependencies &#123; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; testImplementation &apos;junit:junit:4.12&apos; androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos; androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;&#125; 还有一步别忘了，在最外层的local.propersitory中加入你的用户名和密码信息，如下:123#bintraybintray.user=your userbintray.apikey=your apikey 最后，在terminal（Android studio 下面直接有，不需要打开cmd）中运行1gradlew bintrayUpload build成功之后就可以在你的主页中看到这个项目了以上，如有错误，恳请指出]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[利用sm.ms写github项目主页]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%88%A9%E7%94%A8sm.ms%E5%86%99github%E9%A1%B9%E7%9B%AE%E4%B8%BB%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[github上项目首页的README.md的内容可能是别人进入到你的项目之后，唯一可能关注的东西，如果这个地方没有写东西，估计也没有多少人会去下载代码来,我们只需要直接点README.md进行编辑就可以修改主页了，像下面这样 完成之后点击commit change就可以了，这里的图片链接我用的是图床sm.ms，地址如下： https://sm.ms/ 打开之后是这样的 这里我们只需要Browse 后上传图片，然后复制下面的链接就可以了，下面的选项中自动地为我们生成了markdown语法，十分方便，只需要复制就可以在github中的README.md中使用了以上，如有错误，恳请指出]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Parcelable序列化类在Activity、Fragment之间通信]]></title>
    <url>%2F2017%2F11%2F27%2FParcelable%E5%BA%8F%E5%88%97%E5%8C%96%E7%B1%BB%E5%9C%A8Activity%E3%80%81Fragment%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[要让一个类的对象序列化，我们首先得让这个类实现Parcelable接口，我自己定义的一个类如下：12345678910111213141516171819202122232425262728293031323334353637public class NewPlan implements Parcelable&#123; private Long id; private String location; private long startTime; private long endTime; public(Long id, String location, long startTime, long endTime) &#123; this.id = id; this.location = location; this.startTime = startTime; this.endTime = endTime; &#125; public Long getId() &#123; return this.id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getLocation() &#123; return this.location; &#125; public void setLocation(String location) &#123; this.location = location; &#125; public long getStartTime() &#123; return this.startTime; &#125; public void setStartTime(long startTime) &#123; this.startTime = startTime; &#125; public long getEndTime() &#123; return this.endTime; &#125; public void setEndTime(long endTime) &#123; this.endTime = endTime; &#125;&#125; 这时Ide会提醒我们需要实现以下两个函数12345678910@Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(location); dest.writeLong(startTime); &#125; describeContents()函数我们一般不需要对它进行操作，我们需要写的是writeToParcel函数，注意，我们如果需要通信但是不需要得到对象中所有的属性的话，可以少些几个属性，比如我这里就只写了两个属性，做完这一步就可以来写内部生成器了1234567891011121314public static final Parcelable.Creator&lt;NewPlan&gt; CREATOR = new Parcelable.Creator&lt;NewPlan&gt;() &#123; @Override public NewPlan createFromParcel(Parcel source) &#123; NewPlan newPlan = new NewPlan(); newPlan.location = source.readString(); newPlan.startTime = source.readLong(); return newPlan; &#125; @Override public NewPlan[] newArray(int size) &#123; return new NewPlan[size]; &#125; &#125;; 这里要严格按照我们刚刚写入的顺序来写，写入函数并没有给每个属性值都指定相应的Key，重写这两个函数之后，生成器就完成了。接下来我们就可以使用它通过Intent和Bundle在Activity和Fragment之间通信了一. Activity和Activity之间用Intent传递对象 发送123Intent intent = new Intent(MainActivity.this, SecondActivity.class);intent.putExtra(&quot;it&quot;, new NewPlan(0, &quot;湖北武汉&quot;, 20171110,20171111);startActivity(intent); 接收12Intent intent = getIntent();NewPlan mNewPlan = intent.getParcelableExtra()； 当然，除了传输一个对象，我们也可以传递List集合，不过传递对象集合时一定要注意，集合的类型一定是ArrayList，声明为List接口也是不可以的二. Activity与Fragment传递对象 我们在fragment的构造参数中无法传入我们想要传递的数据，官方推荐是使用argument传递消息，用法如下Activity给Fragment设置arguement123mScheduleDetailFragment = new ScheduleDetailFragment();//继承fragment的类bundleDetail.putParcelableArrayList(&quot;newPlan&quot;,new NewPlan(0, &quot;湖北武汉&quot;, 20171110,20171111); //将想要传递的对象放入Bundle mScheduleDetailFragment.setArguments(bundleDetail);//设置argument fragment中获得Bundle中的对象1NewPlan m= this.getArguments().getParcelable(&quot;newPlan&quot;); 需要注意的是，只有在实现Parcelable接口时写入和读取的属性才能在被传递后被读取，没有这样做的属性在传递后为控制，比如说这里我只能得到location和StartTime这两个属性 如有错误，恳请指出]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[另类的Android studio 3.0 报错解决方案]]></title>
    <url>%2F2017%2F11%2F25%2F%E5%8F%A6%E7%B1%BB%E7%9A%84Android%20studio%203.0%20%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[前几天手贱升级了3.0，结果第二天就报出了奇怪的错误，类似于下面这种 Error:too many padding sections on bottom border. Error:com.android.tools.aapt2.Aapt2Exception: AAPT2 error: check logs for details 按照网上给的解决方案，在gradle.properties 中把android.enableAapt2=false 加进去，发现还是报错，这次换成了aapt报错Execution failed for task ‘:app:mergeDebugResources’. &gt; Error: Some file crunching failed, see logs for details ####最后终于找到了问题的根源，就是9path图片的错误，Android studio对图片的要求很高，如果这里错了，很容易就报错了，把图片换掉之后aapt2也不会报错了]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用GeForce Experience在Android studio上截图与录视频]]></title>
    <url>%2F2017%2F11%2F15%2F%E4%BD%BF%E7%94%A8GeForce%20Experience%E5%9C%A8Android%20studio%E4%B8%8A%E6%88%AA%E5%9B%BE%E4%B8%8E%E5%BD%95%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[今天偶然发现了英伟达的显卡管理工具GeForce Experience居然能把录屏和截图的功能在Android studio中使用，在刚刚更新的Android3.0中也没有找到录屏的选项，所以就在这里分享出来了哈哈 首先，当然是下载GeForce Experience了，地址如下：https://www.geforce.cn/drivers 虽然说用N卡的同学很多，但好像装这个东西的并不多，此软件也可以用来优化游戏体验等等。 接下来我们就可以在Android sutdio的虚拟机中使用了，打开虚拟机的时候我们可以看到这样的情况 接下来我们按它说的，按下Alt+Z，然后就出现了这个界面 这个时候按照快捷键截图和录屏还是关闭的，我们需要把即时重放打开才能使用alt+f1截图和alt+f9录屏，文件存放的位置我们只需按alt+z就可以看到，个人觉得是比原来Android studio自带的还要方便！如上，如有错误，恳请指出！]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MVP模式中的小技巧：软引用与弱引用]]></title>
    <url>%2F2017%2F11%2F06%2FMVP%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%9A%E8%BD%AF%E5%BC%95%E7%94%A8%E4%B8%8E%E5%BC%B1%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在MVP当中，过多的类导致了内存控制十分困难，而强引用又很容易导致OOM（GC时不会回收被强引用持有的对象），在这个时候就轮到其他的两中对象引用的方式：软引用与弱引用登场了（虚引用几乎不会被用到） 介绍软引用 在系统内存不够时，会回收被软引用持有的对象，引用方法如下123//T可代表任何对象SoftReference&lt;T&gt; reference = new SoftReference&lt;T&gt;(t0);T t1 = reference.get(); 这里表示t1持有t0的弱引用弱引用 每次系统运行垃圾清理（GC）时都会回收被弱引用持有的对象，引用方法如下，和软引用类似12WeakReference&lt;T&gt; reference = new WeakReference&lt;T&gt;(t0);T t1 = reference.get(); 在MVP模式中，Presenter可能会需要引用Activity的引用，在这里我们就可以使用这两种方式来防止内存泄漏了，如在View层的接口定义了一个getACtivity（）函数，则在Activity中实现的时候可以这么写12345@Override public Activity getActivity() &#123;WeakReference&lt;Activity&gt; weakReference = new WeakReference&lt;Activity&gt;(this);return weakReference.get();&#125; 我们也可以用一个ArrayList来控制weakReference，这样可以避免频繁地new WeakReference，具体代码如下1private List&lt;WeakReference&lt;Activity&gt;&gt; mWeakReferenceList = new ArrayList&lt;WeakReference&lt;Activity&gt;&gt;(); 123456789101112@Override public Activity getActivity() &#123; if (mWeakReferenceList.size() == 0) &#123; WeakReference&lt;Activity&gt; weakReference = new WeakReference&lt;Activity&gt;(this); mWeakReferenceList.add(weakReference); return weakReference.get(); &#125; else &#123; WeakReference&lt;Activity&gt; weakReference = mWeakReferenceList.get(0); LogUtil.v(TAG, &quot;list woeked!&quot;); return weakReference.get(); &#125; &#125; ####运行时可看到打印日志 成功运行了如上，如有错误，恳请指出]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用委托模式在Activity中操作RecyclerView中的item]]></title>
    <url>%2F2017%2F11%2F02%2F%E4%BD%BF%E7%94%A8%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F%E5%9C%A8Activity%E4%B8%AD%E6%93%8D%E4%BD%9CRecyclerView%E4%B8%AD%E7%9A%84item%2F</url>
    <content type="text"><![CDATA[RecyclerView与ListView不同，无法直接通过setItemClicklistener来获得单个item的点击时间，这个时候，我们可以通过在adapter中定义接口，并在Activity中实现相应接口来获得每个Item的点击事件，也就是标准的委托模式。 具体做法如下：第一步 在Adapter类中定义内部接口，我自己定义的如下：1234567891011/** * 在活动中实现的接口 */ public interface SelectItem &#123; /** * 在活动中定义的方法 * @param view view对象 * @param position item的位置 */ void select(View view, int position); &#125; 第二步 在onBindViewHolder方法中定义定义点击事件，并在点击事件中执行该接口的逻辑12345678holder.mainView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (null != mSelectItem) &#123; mSelectItem.select(v, i); &#125; &#125; &#125;); 这样我们就得到了在回调函数中的view和position，这样就能在Activity中对相应的数据进行操作了第四步 在adapter中定义定义设置委托对象的函数123public void setSelectItem(SelectItem selectItem) &#123; mSelectItem = selectItem; &#125; 做好这一步，我们就可以通过在Activity中重写接口中的方法来获得当前点击类的位置和view对象了最后一步，在Activity中重写接口函数123456pickItemAdapter.setSelectItem(new PickItemAdapter.SelectItem() &#123; @Override public void select(View view, int position) &#123; selectItem(position); //对数据进行操作的函数，自己定义的 &#125; &#125;); 这样我们就能很方便地获取当前item的位置，对数据进行操作了！]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用windows10下搭建flask开发环境(python 3)]]></title>
    <url>%2F2017%2F10%2F28%2F%E4%BD%BF%E7%94%A8windows10%E4%B8%8B%E6%90%AD%E5%BB%BAflask%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83(python%203)%2F</url>
    <content type="text"><![CDATA[前几周在windows10下搭建flask环境的时候遇到了几个小问题，拿出来分享一下 首先，安装python3，地址如下：https://www.python.org/downloads/windows/ 安装的时候要注意选中add path选项，让安装程序自动设置好环境变量和路径，这样就免去了我们手动设置的麻烦。安装好python之后我们就可以来安装flask 了，但是一般建议在虚拟环境中安装flask，但是这里有一点需要注意了，windows10下安装虚拟环境比较麻烦，而且easy_install目前已经过期，实际上我们直接运行 pip install virtualenv 就可以了，这时候需要注意，cmd转移到你想要存放的项目目录下再执行这条语句。安装好虚拟环境，进入之后就可以开启虚拟环境了virtualenv env 这一步在windows下好像没啥用，不知道为什么，我们需要在句子前面再加上python -m后才生效，像这样python -m virtualenv env ####激活虚拟环境后我们就可以再虚拟环境中安装flask了pip install flask 到这里就结束了，但是你有没有发现这样做实在是太麻烦了？每次需要运行都要激活虚拟环境后才能运行，cmd用起来也不是很顺手，用windows不就是图个方便嘛！！这时候就该IDE登场了…我用的是pycharm，不过社区版不支持flask，pycharm下载地址如下https://www.jetbrains.com/pycharm/download/#section=windows 安装激活运行后我们可以看到有个flask的选项 我们可以看到有个Project Interpreter:New Virtualenv environment的选项，打开可以看到 没错，只要选择这里我们就能用IDE帮我们自动设置好虚拟环境也，也不需要手动激活了，创建之后可以看到项目默认是运行再虚拟环境之中的不用在意虚拟环境的名字，这是可以自定义的 如上，如有错误，恳请指出]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Dagger2实现MVP模式]]></title>
    <url>%2F2017%2F10%2F22%2FDagger2%E5%AE%9E%E7%8E%B0MVP%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[MVP模式是为了实现View与Model完全解耦而生的模式，而配上Dagger2就能如虎添翼了 MVP模式的图解如下（网上盗的图） 而我们平常在实现MVP模式的时候，应该让View集成接口实现，这样比较容易实现调用，Presenter想要获得某个Activity中的成员的时候也显得更加容易，如下实例接口1234567public interface MainView &#123; /** * 获得当前的活动 * @return 当前活动 */ Activity getActivity(); &#125; Activity继承此接口1public class MainActivity extends AppCompatActivity implements MainView 这样在写Presenter时，我们就可以这样写1234567public class MainPresenterImpel &#123; private final MainView mMainView; @Inject public MainPresenterImpel(MainView mainView) &#123; mMainView = mainView; &#125; 这样我们就可以通过Presenter来调用Activity中写的函数，也可以用它来获得诸如Context等的上帝接口…接下来就轮到用Dagger2实现注入的时候了首先，加入dagger2的依赖12compile &apos;com.google.dagger:dagger:2.11&apos;annotationProcessor &apos;com.google.dagger:dagger-compiler:2.11&apos; 版本号可能不是最新的哦 然后，我们应该实现两个类，Module和ComponentModule这个类相当与构造出一个我们需要注入的对象，而Component则是一个注入的接口，它帮助我们把我们需要注入的对象注入到目标类当中去Module类如下，这里我们需要注意，因为我们的Presenter类构造函数并不是无参的，我们需要到目标类当中获取到MainView才能将它构造出来，但我们可以先这样写123456789101112131415161718192021222324@Modulepublic class MainPresenterImpelModule &#123; private MainView mMainView; public MainPresenterImpelModule(MainView mainView) &#123; mMainView = mainView; &#125; /** * 返回MainPresenterImpelModule * @param mainView constructor必需的参数 * @return MainPresenterImpel实例 */ @Provides MainPresenterImpel provideImpel(MainView mainView) &#123; return new MainPresenterImpel(mainView); &#125; /** * 返回在活动中的MainView * @return 提供创建MainPresenterImpel的MainView */ @Provides MainView provideMainView() &#123; return mMainView; &#125; 在这里Presenter本身也是带构造函数的，这样做主要是为了获取到目标类中的MainView，两个Provides标签则表示了这个函数返回的成员可以帮我们构造Presenter，我们可以看到provideMainView()提供了provideImpel(MainView mainView)中所需的MainView，而它自身的MainView则需要到目标类中获取。Component类如下所示12345678910@Component(modules = MainPresenterImpelModule.class)public interface MainActivityComponent &#123; /** * 这里inject表示注入的意思，这个方法名可以随意更改，但建议就 * 用inject即可。 * @param activity 依赖注入的活动实例 */ void inject(Activity activity); MainPresenterImpel getMainPresenterImpel();&#125; 这里就是把modules类生成的对象注入到Activity类中去，inject函数就是完成注入的方法，而getMainPresenterImpel()可以直接获得Presenter的实例，而不是new 一个出来，这里需要注意的是getMainPresenterImpel()方法是可以不写的，如果不写则需要在Activity用注释的方式获得Presenter实例，如下所示12@injectMainPresenterImpel mMainPresenterImpel； 最后一步，实现注入1234MainActivityComponent mainActivityComponent = DaggerMainActivityComponent.builder() .mainPresenterImpelModule(new MainPresenterImpelModule(this)) .build(); mainActivityComponent.inject(this); 我这样写主要是为了要获得Presenter 的实例，如下1mMainPresenterImpel = mainActivityComponent.getMainPresenterImpel(); 如果采用注释的方法获得实例的话直接注入就ok，像这样1234DaggerMainActivityComponent.builder() .mainPresenterImpelModule(new MainPresenterImpelModule(this)) .build() .inject(this); 如有错误请指正]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android中设置界面PreferenceFragment的用法]]></title>
    <url>%2F2017%2F10%2F19%2FAndroid%E4%B8%AD%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2PreferenceFragment%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[发现Android虽然为我们提供了很好的设置界面的东西（也就是这个PreferenceFragment），但是网上的资料还真是少之又少，可能大家的需求都是自己做设置界面，不稀罕Google为我们做好的，不过既然用到了这个东西，还是拿出来做下笔记 第一步，我们现在res中写一个preferences.xml文件，当然你也可以命名成其他的名字文件目录如下： 根文件布局是PreferenceScreen,定义了一个设置界面，PreferenceCategory则为设置的不同分类，可供选择的Preference有Preference，SwitchPreference，ListPreference以及CheckboxPreference达到，这些都可以放到PreferenceCategory中去，我自己写的界面如下1234567891011121314151617&lt;PreferenceScreen xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;PreferenceCategory android:title=&quot;@string/warning_setting&quot;&gt; &lt;SwitchPreference android:key=&quot;weather_warn&quot; android:title=&quot;@string/weather_warn&quot; android:summaryOff=&quot;开启后在日程开始前会弹出通知栏&quot; android:summaryOn=&quot;会提醒日程&quot; android:defaultValue=&quot;false&quot;/&gt; &lt;ListPreference android:key=&quot;warning_time&quot; android:dependency=&quot;weather_warn&quot; android:title=&quot;@string/waring_time_select&quot; android:summary=&quot;开启提醒则需要设置这项,默认为15分钟&quot; android:entries=&quot;@array/time&quot; android:entryValues=&quot;@array/time&quot; android:defaultValue=&quot;@string/time_default&quot; android:dialogTitle=&quot;请选择提前时间&quot;/&gt; &lt;/PreferenceCategory&gt; &lt;/PreferenceScreen&gt; 显示的效果是这样的 这里的颜色跟定义的style有关系 在这里我使用了一个android:dependency=”weather_warn”属性，这个属性的意思是只有当key为weather_warn的preference值为true时，它才是可以被选择的，我们在preference中可以定义默认的值，summary属性则是选项下面的小字，summaryon和summaryoff可以控制打开开关后显示的小字 第二步，写我们的Java类，继承PreferenceFragment在这里我们需要注意，这个Fragment和普通的Fragment有很大的不同，我们只需要在onCreate中执行addPreferencesFromResource(R.xml.preferences);就可以了，不需要写onCreateView函数，下面是我写的一个示例123456789@Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); addPreferencesFromResource(R.xml.preferences); useDefault = (SwitchPreference) findPreference(&quot;use_default_image&quot;); warnDuration = (ListPreference) findPreference(&quot;warning_time&quot;); updateDuration = (ListPreference) findPreference(&quot;update_duration&quot;); useDefault.setOnPreferenceClickListener(this); updateDuration.setOnPreferenceChangeListener(this); 注意我这里用到的ListPreference和SwitchPreference并不是刚刚我给出来的Preferces.xml中的内容哦，不过用法都是一样的，我们可以发现在这里，获得Preferences的方法很像在Activity中findviewbyid的用法，只不过这里使用的不是id，而是我们刚刚定义的key 这里我们还定义了点击事件，如果像我这样使用的话还需要继承Preference.OnPreferenceClickListener, Preference.OnPreferenceChangeListener这两个接口，然后重写两个方法，这也跟setOnClicklistener的用法十分相似，我们需要注意ListPreference的用法和想CheckPreference和SwitchPreference的方法都不一样，对SwitchPreference、CheckboxPreference应该设置点击事件，而对ListPreference则设置Chane事件。 ListPreference的参考此文http://www.jb51.net/article/75874.htm 以上，如有错误，恳请指出]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[android图片状态栏实现沉浸式状态栏]]></title>
    <url>%2F2017%2F10%2F18%2Fandroid%E5%9B%BE%E7%89%87%E7%8A%B6%E6%80%81%E6%A0%8F%E5%AE%9E%E7%8E%B0%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F%2F</url>
    <content type="text"><![CDATA[沉浸式状态栏实现起来的文章网上有很多了，不过再MD中有一个图片和toolbar一起使用，还会产生过度效果的沉浸式状态栏，像下面这样标题栏XML代码如下123456789101112131415161718192021222324252627282930&lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;192dp&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=&quot;@+id/notification_background&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:contentScrim=&quot;?attr/colorPrimary&quot; app:layout_scrollFlags=&quot;scroll|enterAlways|enterAlwaysCollapsed&quot; android:fitsSystemWindows=&quot;true&quot; app:layout_scrollInterpolator=&quot;@android:anim/decelerate_interpolator&quot; app:toolbarId=&quot;@+id/toolbar&quot;&gt; &lt;ImageView android:id=&quot;@+id/app_bar_image&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:contentDescription=&quot;@string/background&quot; android:scaleType=&quot;centerCrop&quot; /&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; ####如果我们一直使用的是默认图片的画不需要担心，但如果图片是动态改变的，上面状态栏的颜色与下面图片的颜色就有可能会出现很不搭的情况，这个时候就应该动态改变状态栏的颜色了 像下面的图片 这个效果就是用Android supportV7包Graphics中的Palette实现的，它的作用就是将图片中存在的颜色提取出来，我们可以选择其中的任意一种颜色，具体代码如下123456789101112Palette.from(resource).generate(new Palette.PaletteAsyncListener() &#123; @Override public void onGenerated(Palette palette) &#123; Palette.Swatch swatch = palette.getMutedSwatch(); int color; if (swatch != null) &#123; color = swatch.getRgb(); //获取样本颜色 &#125; else &#123; color = primaryColor; //提取样本失败则使用默认颜色 &#125; setThemeColor(color); //设置状态栏颜色，下文中会有具体实现 &#125; &#125;); 代码中resource是图片的Bitmap对象，swatch则为提取出来的色彩样本，我们这里getMutedSwatch()提取出的是柔和的色彩，当然，还有其他色彩可以选择，可以参考以下的文章 http://www.jianshu.com/p/9fcf316031ba 提取完颜色之后，我们就可以用它来设置状态栏的颜色的，改变状态栏颜色可以参考以下代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.zhy.colorfulstatusbar;import android.annotation.TargetApi;import android.app.Activity;import android.content.Context;import android.graphics.Color;import android.os.Build;import android.view.View;import android.view.ViewGroup;/** * Created by zhy on 15/9/21. */public class StatusBarCompat&#123; private static final int INVALID_VAL = -1; private static final int COLOR_DEFAULT = Color.parseColor(&quot;#20000000&quot;); @TargetApi(Build.VERSION_CODES.LOLLIPOP) public static void compat(Activity activity, int statusColor) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; if (statusColor != INVALID_VAL) &#123; activity.getWindow().setStatusBarColor(statusColor); &#125; return; &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; int color = COLOR_DEFAULT; ViewGroup contentView = (ViewGroup) activity.findViewById(android.R.id.content); if (statusColor != INVALID_VAL) &#123; color = statusColor; &#125; View statusBarView = new View(activity); ViewGroup.LayoutParams lp = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, getStatusBarHeight(activity)); statusBarView.setBackgroundColor(color); contentView.addView(statusBarView, lp); &#125; &#125; public static void compat(Activity activity) &#123; compat(activity, INVALID_VAL); &#125; public static int getStatusBarHeight(Context context) &#123; int result = 0; int resourceId = context.getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) &#123; result = context.getResources().getDimensionPixelSize(resourceId); &#125; return result; &#125;&#125; 注： 转载自 http://blog.csdn.net/lmj623565791/article/details/48649563有了这个帮助类来帮助我们改变状态栏的颜色，实现起来就很简单了，实现如下1234private void setThemeColor(int mColor) &#123; mNotificationBackground.setContentScrimColor(mColor); StatusBarCompat.compat(MainActivity.this, mColor);&#125; 注意， mNotificationBackground即为xml代码布局中CollapsingToolbarLayout的实例，这个设置是改变过渡时的颜色。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DialogFragment实现自定义布局的小技巧]]></title>
    <url>%2F2017%2F10%2F13%2FDialogFragment%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[DialogFragment可以说是用起来很方便，也很容易上手的一个类了，上次博客写了一篇关于将DatePicker放入DialogFragment中的文章，之后又遇到了将一整个布局放入DialogFragment中的情况，写着来记录一下 一般来说，我们在DialogFragment中放入一个View只需要像这样写12View v = LayoutInflater.from(getActivity().getApplication()) .inflate(R.layout.datepicker, null); 但是如果我们需要把一整个布局都传入，而且还需要获得布局内控件的引用时，我们就需要一个ViewGroup传入，那这怎么才能在DialogFragment中实现呢？其实还是很简单的，只需要在onCreateView函数中将ViewGroup取出就可以了，具体代码如下：123456@Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,@Nullable Bundle savedInstanceState) &#123; mViewGroup = container; return super.onCreateView(inflater, container, savedInstanceState); &#125; 然后再使用提取出的mViewGroup来获得整个布局123456@NonNull @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; View view = LayoutInflater.from(getContext()) .inflate(R.layout.location_dialog_fragment, mViewGroup, false); ...... &#125; 这样就能轻松把自己写的布局再DialogFragment中展示了，获得布局中的控件就轻而易举了12345mEditLocation = (Button) view.findViewById(R.id.edit_location); mThingStatement=(EditText)view.findViewById(R.id.thing_statement); mSpendMoney = (EditText) view.findViewById(R.id.spend_money); mStartTime = (TextView) view.findViewById(R.id.start_time); mSpendTime = (EditText) view.findViewById(R.id.spend_time); 以上，如有错误，恳请指出]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Rxjava2和Retrofit2实现解析bing每日一图JSON]]></title>
    <url>%2F2017%2F10%2F12%2FRxjava2%E5%92%8CRetrofit2%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90bing%E6%AF%8F%E6%97%A5%E4%B8%80%E5%9B%BEJSON%2F</url>
    <content type="text"><![CDATA[一直想学习一下Rxjava和Retrofit实现网络请求，正好这几天准备实现一个下载bing每日一图的功能，就实践了一下 网上找的带有每日一图链接的资源如下https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1 打开之后会得到一长串JSON格式的数据1&#123;&quot;images&quot;:[&#123;&quot;startdate&quot;:&quot;20171006&quot;,&quot;fullstartdate&quot;:&quot;201710061600&quot;,&quot;enddate&quot;:&quot;20171007&quot;,&quot;url&quot;:&quot;/az/hprichbg/rb/VallesMarineris_ZH-CN10598461085_1920x1080.jpg&quot;,&quot;urlbase&quot;:&quot;/az/hprichbg/rb/VallesMarineris_ZH-CN10598461085&quot;,&quot;copyright&quot;:&quot;火星上的峡谷系统-水手号峡谷地区上的小行星 (© Detlev van Ravenswaay/Getty Images)&quot;,&quot;copyrightlink&quot;:&quot;http://www.bing.com/search?q=%E7%81%AB%E6%98%9F%E5%B3%A1%E8%B0%B7&amp;form=hpcapt&amp;mkt=zh-cn&quot;,&quot;quiz&quot;:&quot;/search?q=Bing+homepage+quiz&amp;filters=WQOskey:%22HPQuiz_20171006_VallesMarineris%22&amp;FORM=HPQUIZ&quot;,&quot;wp&quot;:true,&quot;hsh&quot;:&quot;5b69b96f1ea30eb5ec187173de25ef3c&quot;,&quot;drk&quot;:1,&quot;top&quot;:1,&quot;bot&quot;:1,&quot;hs&quot;:[]&#125;],&quot;tooltips&quot;:&#123;&quot;loading&quot;:&quot;正在加载...&quot;,&quot;previous&quot;:&quot;上一个图像&quot;,&quot;next&quot;:&quot;下一个图像&quot;,&quot;walle&quot;:&quot;此图片不能下载用作壁纸。&quot;,&quot;walls&quot;:&quot;下载今日美图。仅限用作桌面壁纸。&quot;&#125;&#125; 带有bing每日一图的链接显而易见了，就是 “urlbase”:”/az/hprichbg/rb/VallesMarineris_ZH-CN10598461085” #####当然 这仅仅是我写这篇文章时候的链接，每天数据都会不同 接下来我们来开始实现Rxjava2和Retrofit2解析JSON了，添加依赖如下 compile ‘com.squareup.retrofit2:retrofit:2.3.0’ compile ‘io.reactivex.rxjava2:rxandroid:2.0.1’ compile ‘io.reactivex.rxjava2:rxjava:2.1.3’ compile ‘com.squareup.retrofit2:converter-gson:2.3.0’ compile ‘com.squareup.retrofit2:adapter-rxjava2:2.3.0’ 因为okhttp已经集成在retrofit中了，所有这里不需要再加入okhttp的依赖一步一步来，首先，我们先根据返回的数据写一个实体类，这里有一个很方便的工具GsonFormat，可以直接根据网页中的信息生成gettter setter及内部类，还没有安装此插件的同学可以参考这一篇博文http://blog.csdn.net/dakaring/article/details/46300963 我们也可以添加自己的函数，这样可以很方便地得到想要的数据，如下123456String getURL() &#123; return images.get(0).getUrl(); &#125;String getDate() &#123; return images.get(0).getEnddate();&#125; 这里就是我自己添加的函数完成实体类之后就可以来定义接口了12345678interface ImageAPI &#123; /** * 网络请求 * @return 实体类 */ @GET(&quot;HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&quot;) Flowable&lt;ImageBean&gt; getImage();&#125; 这里需要注意的是，在@GET后面添加的是上面的链接https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1的后半部分，这也是retrofit 的用法很重要的一点，当然，在我们这里并没有体现出来这种方式的优点，但在其他地方，可以起到很好的解耦作用。我们这里定义的接口直接就返回了ImageBean类，在后面就可以直接提取数据了。Flowable则是Rxjava2新引入的东西，它可以更好地处理同步异步的关系。最后一步就是实现了，我们在上一步只给出了链接的下半部分，在这里我们将将上半部分封装进retrofit，这样完整的链接就给出了1private static final String BASE_URL = &quot;https://cn.bing.com&quot;; 12345Retrofit retrofit = new Retrofit.Builder() .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .baseUrl(&quot;https://cn.bing.com/&quot;) .build(); 在这里我们实现了Retrofit 的初始化，以及将JSON转化，其中addCallAdapterFactory(RxJava2CallAdapterFactory.create())表示添加Rxjava2与Retrofit2的适配器，addConverterFactory(GsonConverterFactory.create())则表示添加Json转化工具。最后一步 实现接口1234567891011121314151617181920212223242526272829final ImageAPI imageAPI = retrofit.create(ImageAPI.class); LogUtil.v(TAG, &quot;downloadUrl&quot;); imageAPI.getImage() .subscribeOn(Schedulers.io()) .observeOn(Schedulers.newThread()) .subscribe(new Subscriber&lt;ImageBean&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; s.request(Long.MAX_VALUE); &#125; @Override public void onNext(ImageBean imageBean) &#123; LogUtil.v(TAG, &quot;next&quot;); LogUtil.d(TAG, BASE_URL + imageBean.getURL()); LogUtil.d(TAG, imageBean.getDate()); &#125; @Override public void onError(Throwable t) &#123; t.printStackTrace(); LogUtil.v(TAG, &quot;error&quot;); &#125; @Override public void onComplete() &#123; LogUtil.v(TAG, &quot;complete&quot;); &#125; &#125;); 这里需要注意onSubscribe函数中必须对s进行处理，这里表示一次性处理几次数据，若不处理，则onNext不生效！到这里就结束了，可以得到完整的每日一图链接，如有差错恳请指出！]]></content>
      <categories>
        <category>Android网络开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ButterKnife在RecyclerView adapter中的使用]]></title>
    <url>%2F2017%2F10%2F08%2FButterKnife%E5%9C%A8RecyclerView%20adapter%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[ButterKnife是一个用起来十分方便的开源库，我们只需要用一个小小的插件ButterKnifeZenezny就免去了写一大袋findViewbyId的书写，不过在adapter中，插件自动生成的方式就步行了，我们一般都需要在ViewHolder中实现依赖注入,这时候我们需要像下面这样12345678910111213141516public static class LocationViewHolder extends RecyclerView.ViewHolder &#123; @BindView(R.id.location_show) TextView locationShow; @BindView(R.id.statement_show) TextView stateementShow; @BindView(R.id.time_show) TextView timeShow; @BindView(R.id.spend_money_show) TextView spendMoneyShow; @BindView(R.id.spend_time_show) TextView spendTimeShow; public LocationViewHolder(View itemView) &#123; super(itemView); ButterKnife.bind(this, itemView); &#125; &#125; 这种方式就可以实现用ButterKnife注入view，简化了我们的书写，当然，对项目中用了ButterKnife的强迫症患者来说，实在是很棒了。。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NDK实现毛玻璃效果完全教程]]></title>
    <url>%2F2017%2F10%2F07%2FNDK%E5%AE%9E%E7%8E%B0%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C%E5%AE%8C%E5%85%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前几天准备做一个动态的毛玻璃效果，中间查阅了很多网上的资料，我用的方法是CMake做NDK，由C/C++来实现图片的毛玻璃化，废话不多说，具体方法如下 首先，当然是配置NDK环境，这类网上教程很多，就麻烦自行配制了，参考教程如下http://blog.csdn.net/xiaoyu_93/article/details/53082088 这里配置好之后我们还需要在gradle中配置一下NDK开发所需要的库1234567891011externalNativeBuild &#123; cmake &#123; cppFlags &quot;-std=c++11 -frtti -fexceptions&quot; &#125; ndk &#123; moduleName &quot;blur_lib&quot; // 动态库名称 abiFilters &quot;armeabi&quot;, &quot;armeabi-v7a&quot;, &quot;x86&quot; // 相应的架构平台 ldLibs &quot;log&quot; //log输出 ldLibs &quot;jnigraphics&quot; //graphic相关jni &#125; &#125; 来编写C/C++文件了，我是直接在系统默认的C++库中做，也就是Native-lib.cpp，代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class com_pecoo_blurjnidemo_NativeHelper */#ifndef _Included_com_pecoo_blurjnidemo_NativeHelper#define _Included_com_pecoo_blurjnidemo_NativeHelper#ifdef __cplusplusextern &quot;C&quot; &#123;#endif/* * Class: com_pecoo_blurjnidemo_NativeHelper * Method: blurBitmap * Signature: (Ljava/lang/Object;I)V */#include &lt;android/log.h&gt;#include &lt;android/bitmap.h&gt;#include &quot;stackblur.h&quot; // 在第一步中创建的.h头文件，下面可以调用里面的方法// log宏定义#define TAG &quot;Native_Blur_Jni&quot;#define LOG_D(...) __android_log_print(ANDROID_LOG_DEBUG,TAG ,__VA_ARGS__)JNIEXPORT void JNICALL Java_com_android_betterway_utils_BlurUtil_blurBitmap (JNIEnv *env, jclass obj, jobject bitmapIn, jint r)&#123; AndroidBitmapInfo infoIn; void *pixels; // 获取bitmap的信息 if (AndroidBitmap_getInfo(env, bitmapIn, &amp;infoIn) != ANDROID_BITMAP_RESULT_SUCCESS) &#123; LOG_D(&quot;AndroidBitmap_getInfo failed!&quot;); return; &#125; // 检测bitmap是不是这两种格式，因为算法中只有对这两种图片会做处理 if (infoIn.format != ANDROID_BITMAP_FORMAT_RGBA_8888 &amp;&amp; infoIn.format != ANDROID_BITMAP_FORMAT_RGB_565) &#123; LOG_D(&quot;Only support ANDROID_BITMAP_FORMAT_RGBA_8888 and ANDROID_BITMAP_FORMAT_RGB_565&quot;); return; &#125; // 锁定图片 if (AndroidBitmap_lockPixels(env, bitmapIn, &amp;pixels) != ANDROID_BITMAP_RESULT_SUCCESS) &#123; LOG_D(&quot;AndroidBitmap_lockPixels failed!&quot;); return; &#125; // 得到宽高 int h = infoIn.height; int w = infoIn.width; if (infoIn.format == ANDROID_BITMAP_FORMAT_RGBA_8888) &#123; // 调用stackblur.c中的blur_ARGB_8888()或blur_RGB_565() pixels = blur_ARGB_8888((int *) pixels, w, h, r); &#125; else if (infoIn.format == ANDROID_BITMAP_FORMAT_RGB_565) &#123; pixels = blur_RGB_565((short *) pixels, w, h, r); &#125; // 对应上面的AndroidBitmap_lockPixels（） AndroidBitmap_unlockPixels(env, bitmapIn);&#125;#ifdef __cplusplus&#125;#endif#endif 当然，这里还有其他的文件，分别如下，这是来定义图片色彩通道的文件 stackblur.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413#include &lt;malloc.h&gt;#define ABS(a) ((a)&lt;(0)?(-a):(a))#define MAX(a, b) ((a)&gt;(b)?(a):(b))#define MIN(a, b) ((a)&lt;(b)?(a):(b))/*************************************************Function: StackBlurDescription: Using stack way blurred image pixelsCalls: mallocTable Accessed: NULLTable Updated: NULLInput: Collection of pixels, wide image, image is high, the blur radiusOutput: After return to fuzzy collection of pixelsReturn: After return to fuzzy collection of pixelsOthers: NULL*************************************************/int *blur_ARGB_8888(int *pix, int w, int h, int radius) &#123; int wm = w - 1; int hm = h - 1; int wh = w * h; int div = radius + radius + 1; short *r = (short *) malloc(wh * sizeof(short)); short *g = (short *) malloc(wh * sizeof(short)); short *b = (short *) malloc(wh * sizeof(short)); int rsum, gsum, bsum, x, y, i, p, yp, yi, yw; int *vmin = (int *) malloc(MAX(w, h) * sizeof(int)); int divsum = (div + 1) &gt;&gt; 1; divsum *= divsum; short *dv = (short *) malloc(256 * divsum * sizeof(short)); for (i = 0; i &lt; 256 * divsum; i++) &#123; dv[i] = (short) (i / divsum); &#125; yw = yi = 0; int(*stack)[3] = (int (*)[3]) malloc(div * 3 * sizeof(int)); int stackpointer; int stackstart; int *sir; int rbs; int r1 = radius + 1; int routsum, goutsum, boutsum; int rinsum, ginsum, binsum; for (y = 0; y &lt; h; y++) &#123; rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0; for (i = -radius; i &lt;= radius; i++) &#123; p = pix[yi + (MIN(wm, MAX(i, 0)))]; sir = stack[i + radius]; sir[0] = (p &amp; 0xff0000) &gt;&gt; 16; sir[1] = (p &amp; 0x00ff00) &gt;&gt; 8; sir[2] = (p &amp; 0x0000ff); rbs = r1 - ABS(i); rsum += sir[0] * rbs; gsum += sir[1] * rbs; bsum += sir[2] * rbs; if (i &gt; 0) &#123; rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; &#125; else &#123; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; &#125; &#125; stackpointer = radius; for (x = 0; x &lt; w; x++) &#123; r[yi] = dv[rsum]; g[yi] = dv[gsum]; b[yi] = dv[bsum]; rsum -= routsum; gsum -= goutsum; bsum -= boutsum; stackstart = stackpointer - radius + div; sir = stack[stackstart % div]; routsum -= sir[0]; goutsum -= sir[1]; boutsum -= sir[2]; if (y == 0) &#123; vmin[x] = MIN(x + radius + 1, wm); &#125; p = pix[yw + vmin[x]]; sir[0] = (p &amp; 0xff0000) &gt;&gt; 16; sir[1] = (p &amp; 0x00ff00) &gt;&gt; 8; sir[2] = (p &amp; 0x0000ff); rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; rsum += rinsum; gsum += ginsum; bsum += binsum; stackpointer = (stackpointer + 1) % div; sir = stack[(stackpointer) % div]; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; rinsum -= sir[0]; ginsum -= sir[1]; binsum -= sir[2]; yi++; &#125; yw += w; &#125; for (x = 0; x &lt; w; x++) &#123; rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0; yp = -radius * w; for (i = -radius; i &lt;= radius; i++) &#123; yi = MAX(0, yp) + x; sir = stack[i + radius]; sir[0] = r[yi]; sir[1] = g[yi]; sir[2] = b[yi]; rbs = r1 - ABS(i); rsum += r[yi] * rbs; gsum += g[yi] * rbs; bsum += b[yi] * rbs; if (i &gt; 0) &#123; rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; &#125; else &#123; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; &#125; if (i &lt; hm) &#123; yp += w; &#125; &#125; yi = x; stackpointer = radius; for (y = 0; y &lt; h; y++) &#123; // Preserve alpha channel: ( 0xff000000 &amp; pix[yi] ) pix[yi] = (0xff000000 &amp; pix[yi]) | (dv[rsum] &lt;&lt; 16) | (dv[gsum] &lt;&lt; 8) | dv[bsum]; rsum -= routsum; gsum -= goutsum; bsum -= boutsum; stackstart = stackpointer - radius + div; sir = stack[stackstart % div]; routsum -= sir[0]; goutsum -= sir[1]; boutsum -= sir[2]; if (x == 0) &#123; vmin[y] = MIN(y + r1, hm) * w; &#125; p = x + vmin[y]; sir[0] = r[p]; sir[1] = g[p]; sir[2] = b[p]; rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; rsum += rinsum; gsum += ginsum; bsum += binsum; stackpointer = (stackpointer + 1) % div; sir = stack[stackpointer]; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; rinsum -= sir[0]; ginsum -= sir[1]; binsum -= sir[2]; yi += w; &#125; &#125; free(r); free(g); free(b); free(vmin); free(dv); free(stack); return (pix);&#125;short *blur_RGB_565(short *pix, int w, int h, int radius) &#123; int wm = w - 1; int hm = h - 1; int wh = w * h; int div = radius + radius + 1; short *r = (short *) malloc(wh * sizeof(short)); short *g = (short *) malloc(wh * sizeof(short)); short *b = (short *) malloc(wh * sizeof(short)); int rsum, gsum, bsum, x, y, p, i, yp, yi, yw; int *vmin = (int *) malloc(MAX(w, h) * sizeof(int)); int divsum = (div + 1) &gt;&gt; 1; divsum *= divsum; short *dv = (short *) malloc(256 * divsum * sizeof(short)); for (i = 0; i &lt; 256 * divsum; i++) &#123; dv[i] = (short) (i / divsum); &#125; yw = yi = 0; int(*stack)[3] = (int (*)[3]) malloc(div * 3 * sizeof(int)); int stackpointer; int stackstart; int *sir; int rbs; int r1 = radius + 1; int routsum, goutsum, boutsum; int rinsum, ginsum, binsum; for (y = 0; y &lt; h; y++) &#123; rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0; for (i = -radius; i &lt;= radius; i++) &#123; p = pix[yi + (MIN(wm, MAX(i, 0)))]; sir = stack[i + radius]; sir[0] = (((p) &amp; 0xF800) &gt;&gt; 11) &lt;&lt; 3; sir[1] = (((p) &amp; 0x7E0) &gt;&gt; 5) &lt;&lt; 2; sir[2] = ((p) &amp; 0x1F) &lt;&lt; 3; rbs = r1 - ABS(i); rsum += sir[0] * rbs; gsum += sir[1] * rbs; bsum += sir[2] * rbs; if (i &gt; 0) &#123; rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; &#125; else &#123; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; &#125; &#125; stackpointer = radius; for (x = 0; x &lt; w; x++) &#123; r[yi] = dv[rsum]; g[yi] = dv[gsum]; b[yi] = dv[bsum]; rsum -= routsum; gsum -= goutsum; bsum -= boutsum; stackstart = stackpointer - radius + div; sir = stack[stackstart % div]; routsum -= sir[0]; goutsum -= sir[1]; boutsum -= sir[2]; if (y == 0) &#123; vmin[x] = MIN(x + radius + 1, wm); &#125; p = pix[yw + vmin[x]]; sir[0] = (((p) &amp; 0xF800) &gt;&gt; 11) &lt;&lt; 3; sir[1] = (((p) &amp; 0x7E0) &gt;&gt; 5) &lt;&lt; 2; sir[2] = ((p) &amp; 0x1F) &lt;&lt; 3; rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; rsum += rinsum; gsum += ginsum; bsum += binsum; stackpointer = (stackpointer + 1) % div; sir = stack[(stackpointer) % div]; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; rinsum -= sir[0]; ginsum -= sir[1]; binsum -= sir[2]; yi++; &#125; yw += w; &#125; for (x = 0; x &lt; w; x++) &#123; rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0; yp = -radius * w; for (i = -radius; i &lt;= radius; i++) &#123; yi = MAX(0, yp) + x; sir = stack[i + radius]; sir[0] = r[yi]; sir[1] = g[yi]; sir[2] = b[yi]; rbs = r1 - ABS(i); rsum += r[yi] * rbs; gsum += g[yi] * rbs; bsum += b[yi] * rbs; if (i &gt; 0) &#123; rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; &#125; else &#123; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; &#125; if (i &lt; hm) &#123; yp += w; &#125; &#125; yi = x; stackpointer = radius; for (y = 0; y &lt; h; y++) &#123; // Not have alpha channel pix[yi] = ((((dv[rsum]) &gt;&gt; 3) &lt;&lt; 11) | (((dv[gsum]) &gt;&gt; 2) &lt;&lt; 5) | ((dv[bsum]) &gt;&gt; 3)); rsum -= routsum; gsum -= goutsum; bsum -= boutsum; stackstart = stackpointer - radius + div; sir = stack[stackstart % div]; routsum -= sir[0]; goutsum -= sir[1]; boutsum -= sir[2]; if (x == 0) &#123; vmin[y] = MIN(y + r1, hm) * w; &#125; p = x + vmin[y]; sir[0] = r[p]; sir[1] = g[p]; sir[2] = b[p]; rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; rsum += rinsum; gsum += ginsum; bsum += binsum; stackpointer = (stackpointer + 1) % div; sir = stack[stackpointer]; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; rinsum -= sir[0]; ginsum -= sir[1]; binsum -= sir[2]; yi += w; &#125; &#125; free(r); free(g); free(b); free(vmin); free(dv); free(stack); return (pix);&#125; 代码有些长。。。还好不用自己敲以及它对应的头文件 stackblur.h123456#ifndef BETTERWAY_STACKBLUR_H#define BETTERWAY_STACKBLUR_Hint *blur_ARGB_8888(int *, int, int, int);short *blur_RGB_565(short *, int, int, int);#endif //BETTERWAY_STACKBLUR_H 这些都做完了之后，就可以在CmakeList.text文件中加载了，如下所示，注意，我这里只给出了与默认文件不一样的部分，注意，这里的jnigraphics虽然说我们已经在gradle中添加，但在这里不添加的话还是会报错，但是c/c++中使用Log的库只要在gradle中添加就可以，这里实在是没弄明白，如有高手知道请告知，感激不尽。123456789101112131415add_library( # Sets the name of the library. stackblur # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/stackblur.c )target_link_libraries( # Specifies the target library. native-lib stackblur jnigraphics # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125; ) ##### 因为我是在默认的native-lib中实现的函数，所以并没有添加另外的文件，当然，如果你实在另外的C/C++文件中实现的，就要添加其他的 最后在java函数中调用native函数，就可以实现图片的毛玻璃化了，这里给出我的实现方法123456789public static Bitmap blur(Bitmap srcBitmap) &#123; blurBitmap(srcBitmap, 13); return srcBitmap; &#125; static &#123; System.loadLibrary(&quot;native-lib&quot;); &#125; // 参数r为对bitmap虚化的程度范围 static native void blurBitmap(Object bitmap, int r); 附加一点东西，为了实现截图的毛玻璃效果，我们一般还会压缩一下图片，这样才能使毛玻璃效果更快更自然，这里给出一个减少图片像素的方法12345678910111213public static Bitmap compressScale(Bitmap bmp) &#123; // 尺寸压缩倍数,值越大，图片尺寸越小 int ratio = 5; // 压缩Bitmap到对应尺寸 Bitmap result = Bitmap.createBitmap(bmp.getWidth() / ratio, bmp.getHeight() / ratio, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(result); Rect rect = new Rect(0, 0, bmp.getWidth() / ratio, bmp.getHeight() / ratio); canvas.drawBitmap(bmp, null, rect, null); ByteArrayOutputStream baos = new ByteArrayOutputStream(); // 把压缩后的数据存放到baos中 result.compress(Bitmap.CompressFormat.JPEG, 60 ,baos); return result; &#125; 配合上这个方法，毛玻璃效果就能更快得实现了如上，如有错误，恳请指正]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DialogFragment实现DatePicker]]></title>
    <url>%2F2017%2F10%2F05%2FDialogFragment%E5%AE%9E%E7%8E%B0DatePicker%2F</url>
    <content type="text"><![CDATA[先上效果图 要实现这个效果，首先，我们得先创建一个Dialogfragment，注意我们只重写onCreateDialog函数，其他的函数就不用管了，在此之前我们先写好xml文件，很简单，只需要把datepicker作为根布局就可以了datepicker.xml1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;DatePicker xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/datePicker&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:calendarViewShown=&quot;false&quot;&gt;&lt;/DatePicker&gt; 我们需要在onCreateDialog返回一个dialog，这个dialog我们一般都使用AlertDialog，现在官方已经不推荐使用Dialog了，具体代码如下：12345678910111213141516View v = LayoutInflater.from(getActivity()) .inflate(R.layout.datepicker, null); final DatePicker datePicker = (DatePicker)v; datePicker.setMinDate(TimeUtil.getDayLong()); //设置可选择的最小日期，TimeUtil是我自己写的工具类，返回当前日期的long值 AlertDialog.Builder dialogbuilder = new AlertDialog.Builder(getActivity()) .setView(datePicker) .setTitle(R.string.datepicker_title) .setPositiveButton(R.string.button_sure, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; //添加自己的代码 &#125; &#125; &#125;) .setNegativeButton(R.string.button_cancel, null); return dialogbuilder.create(); alertdialog的构造用到了十分典型的Builder模式，这个模式可以使我们更容易组织alerdialog。 写完了dialogfragment之后，就可以在活动中调用它了，代码十分简单12345FragmentManager manager = getSupportFragmentManager(); DatePickerFragment datePickerFragment = new DatePickerFragment();//datePickerFragment即为我们写的继承dialogfragment的组件datePickerFragment.setActitityType(activityType);datePickerFragment.show(manager, &quot;DatePickerFragment&quot;); 不过这个dialogfragment显示的方式可能有些难看，这里给出我的一个动画的实现方式1234if (dialog.getWindow() != null) &#123; Window window=dialog.getWindow(); window.setWindowAnimations(R.style.dialogAnim); &#125; 动画的xml代码如下：1234&lt;style name=&quot;dialogAnim&quot; mce_bogus=&quot;1&quot; parent=&quot;android:Animation&quot;&gt; &lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@anim/dialog_push_in&lt;/item&gt; &lt;item name=&quot;android:windowExitAnimation&quot;&gt;@anim/dialog_push_out&lt;/item&gt; &lt;/style&gt; dialog_push_in123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;scale android:duration=&quot;@android:integer/config_shortAnimTime&quot; android:fromYScale=&quot;0.5&quot; android:fromXScale=&quot;0.4&quot; android:toXScale=&quot;1.0&quot; android:toYScale=&quot;1.0&quot; /&gt; &lt;alpha android:duration=&quot;@android:integer/config_shortAnimTime&quot; android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot; /&gt;&lt;/set&gt; dialog_push_out123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;scale android:duration=&quot;@android:integer/config_shortAnimTime&quot; android:fromYScale=&quot;1.0&quot; android:fromXScale=&quot;1.0&quot; android:toXScale=&quot;0.4&quot; android:toYScale=&quot;0.5&quot; /&gt; &lt;alpha android:duration=&quot;@android:integer/config_shortAnimTime&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.0&quot; /&gt;&lt;/set&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自定义ViewGroup之扩展FloatingActionButton]]></title>
    <url>%2F2017%2F10%2F02%2F%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup%E4%B9%8B%E6%89%A9%E5%B1%95FloatingActionButton%2F</url>
    <content type="text"><![CDATA[本文主要是实现一个ViewGroup容器，并实现在内部自由放置FloatingActionButton，与各种FloatingActionButton开源库不同的是只侧重基础的实现，但实际效果还算美观。 效果图如下所示 首先，我们先实现一个类似于竖直排布的线性布局的ViewGroup，创建一个FloatingActionButtonMenu类集成ViewGroup第一步 获得父类的arginLayoutParams，这里直接使用系统自带attrs就可以了，要注意的是方法返回值必须为ViewGroup.LayoutParams，否则在运行时会报错，这与我们直接按ctrl+o选择的结果不一样。12345@Overridepublic ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) &#123; Log.d(tag, &quot;generateLayoutParams&quot;); return new MarginLayoutParams(getContext(), attrs); &#125; 第二步，重写onMeasure方法，这一步主要时得到我们实现的ViewGroup最后所占的空间，属性中match_parent与wrap_parent所对应的分别是MeasureSpec.EXACTLY和MeasureSpec.AT_MOST12345678910111213141516171819202122232425262728293031323334@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // 获得此ViewGroup上级容器为其推荐的宽和高，以及计算模式 // 所得既为设置match_parent时的大小 Log.d(tag, &quot;onMeasure&quot;); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int sizeWidth = MeasureSpec.getSize(widthMeasureSpec); int sizeHeight = MeasureSpec.getSize(heightMeasureSpec); // 计算出所有的childView的宽和高 measureChildren(widthMeasureSpec, heightMeasureSpec); // 记录如果是wrap_content是设置的宽和高 int childCount = getChildCount(); MarginLayoutParams layoutParms = null; //宽为各个子View的最大值，高为总和 int width = 0, height = 0; for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); layoutParms = (MarginLayoutParams) childView.getLayoutParams(); int cWidth = childView.getMeasuredWidth() + layoutParms.rightMargin + layoutParms.leftMargin; int cHeight = childView.getMeasuredHeight(); if (cWidth &gt; width) &#123; width = cWidth; &#125; height += cHeight + layoutParms.bottomMargin + layoutParms.topMargin; &#125; /** * 若为match_parent则将宽高设置为上级推荐的大小 * 否则则设置为计算出的大小，即为wrap_parent */ setMeasuredDimension((widthMode == MeasureSpec.EXACTLY) ? sizeWidth : width, (heightMode == MeasureSpec.EXACTLY) ? sizeHeight : height); &#125; 第三步，重写onLayout函数，这个函数主要是制定容器中各个view相对于容器的位置，这里需要注意的是在进行计算时尽量使用子view的属性，用容器的属性进行计算可能会得到无法显示的结果 四个点坐标的位置如下图所示 我们这里所实现的布局类似于叠罗汉，在xml文件中最下面的控件，在容器中就是在最底部，在这里我还使除了控制按钮之外的所有view变为透明状态同时不可点击，这样做主要是使动画更容易实现12345678910111213141516171819202122232425262728@Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; Log.d(tag, &quot;onLayout&quot;); int cCount = getChildCount(); MarginLayoutParams layoutParams; /** * 遍历所有childView根据其宽和高 * 指定相应位置 */ int height = 0; for (int i = 0; i &lt; cCount; i++) &#123; View childView = getChildAt(i); layoutParams = (MarginLayoutParams) childView.getLayoutParams(); int cl = layoutParams.leftMargin; int cr = cl + childView.getMeasuredWidth(); int ct = layoutParams.topMargin + height; int cb = ct + childView.getMeasuredHeight(); childView.layout(cl, ct, cr, cb); height += childView.getMeasuredHeight() + layoutParams.bottomMargin; //使上面的子view全都不可见 if (i != cCount- 1)&#123; childView.setAlpha(0f); childView.setClickable(false); &#125; &#125; state = HIDE; setClick(getChildAt(cCount- 1)); &#125; 在最后面实现的函数是把最底部的view作为一个开关，由它来控制其他子view是否可见 点击事件函数如下123456789101112131415161718192021222324252627282930313233343536373839public void setClick(final View view)&#123; view.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; if (state == HIDE) &#123; //当状态为不可见时，点击按钮弹出所有隐藏view ObjectAnimator animator = ObjectAnimator.ofFloat(view, &quot;rotation&quot;, 0f, rotation); animator.setDuration(duration); animator.start(); for (int i = 0; i&lt; getChildCount() - 1; i++)&#123; View childView = getChildAt(i); //实现淡入效果 ObjectAnimator chlidanimator = ObjectAnimator.ofFloat(childView, &quot;alpha&quot;, 0f, 1f); //实现拉伸效果 ObjectAnimator otheranimator = ObjectAnimator.ofFloat(childView, &quot;scaleX&quot;, 1.0f, 1.2f, 1.0f); otheranimator.setDuration(400); chlidanimator.setDuration(400); otheranimator.start(); chlidanimator.start(); childView.setClickable(true); state = SHOW; &#125; &#125; else &#123; //当状态为可见时，点击按钮隐藏所有view ObjectAnimator animator = ObjectAnimator.ofFloat(view, &quot;rotation&quot;, rotation, 0f); animator.setDuration(duration); animator.start(); for (int i = 0; i&lt; getChildCount() - 1; i++)&#123; View childView = getChildAt(i); ObjectAnimator chlidanimator = ObjectAnimator.ofFloat(childView, &quot;alpha&quot;, 1f, 0f); chlidanimator.setDuration(400); chlidanimator.start(); childView.setClickable(false); state = HIDE; &#125; &#125; &#125; &#125;); &#125; XML代码如下1234567891011121314151617181920212223242526272829303132333435363738394041&lt;com.android.betterway.myview.FloatingActionButtonMenu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;172dp&quot; android:layout_gravity=&quot;bottom|right&quot; android:background=&quot;#00000000&quot; android:layout_margin=&quot;15dp&quot; &gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/floatingActionButton7&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;10dp&quot; android:clickable=&quot;true&quot; android:elevation=&quot;4dp&quot; app:fabSize=&quot;mini&quot; app:srcCompat=&quot;@drawable/ic_action_addsmart&quot; fab:backgroundTint=&quot;@color/primary_light&quot;/&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/floatingActionButton6&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;10dp&quot; android:clickable=&quot;true&quot; app:fabSize=&quot;mini&quot; app:srcCompat=&quot;@drawable/ic_action_addnormal&quot; fab:backgroundTint=&quot;@color/primary_light&quot; fab:elevation=&quot;4dp&quot;/&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/floatingActionButton5&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;4dp&quot; android:clickable=&quot;true&quot; app:fabSize=&quot;normal&quot; fab:elevation=&quot;5dp&quot; app:srcCompat=&quot;@drawable/ic_action_add&quot; fab:backgroundTint=&quot;@color/accent&quot;/&gt; &lt;/com.android.betterway.myview.FloatingActionButtonMenu&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用git bash下载Android源码遇到的问题解决方法]]></title>
    <url>%2F2017%2F01%2F25%2F%E4%BD%BF%E7%94%A8git%20bash%E4%B8%8B%E8%BD%BDAndroid%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[这几天准备用SI在windows环境下研究以下源码，看了网上的教程之后因为手头上有梯子，就准备使用git把源码都clone下来，但是在clone的时候出现了如下的问题 即使vpn开了全局代理模式，git还是会无法连接，于是乎就去网上搜了下解决方案，然后就有了如下几个尝试 还是以失败告终，然后在StackOverflow上看到了如下的一个问题https://stackoverflow.com/questions/18356502/github-failed-to-connect-to-github-443-windows-failed-to-connect-to-github 回答中有一个解决方案是这样的，在git bash中输入以下配置语句git config –global http.proxy 127.0.0.1:8087 但是我们使用这个方案也是失败的 原因就是这个解决方法是针对国外网络的，而我们需要配置的是vpn所使用的代理服务器端口，比如说我使用的latern，代理服务器端口如下所示： 我应该配置的方法是这样的 之后就可以连接上了，附一张连接成功的图 以上，如有错误，恳请指出]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
</search>
